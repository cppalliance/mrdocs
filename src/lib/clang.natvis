<?xml version="1.0" encoding="utf-8"?>
<!--
Visual Studio Native Debugging Visualizers for LLVM

For Visual Studio 2013 only, put this file into
"%USERPROFILE%\Documents\Visual Studio 2013\Visualizers" or create a symbolic link so it updates automatically.

For later versions of Visual Studio, no setup is required-->
<AutoVisualizer xmlns="http://schemas.microsoft.com/vstudio/debugger/natvis/2010">



    <Type Name="clang::TemplateArgumentLoc">
        <DisplayString IncludeView="cpp">{Argument,view(cpp)}</DisplayString>
        <DisplayString>{Argument}</DisplayString>
    </Type>
    <Type Name="clang::TemplateArgument">
        <DisplayString IncludeView="cpp" Condition="Integer.Kind == clang::TemplateArgument::ArgKind::Type">{*(clang::QualType *)&amp;TypeOrValue.V,view(cpp)}</DisplayString>
        <DisplayString Condition="Integer.Kind == clang::TemplateArgument::ArgKind::Type">{(clang::TemplateArgument::ArgKind)TypeOrValue.Kind,en} template argument: {*(clang::QualType *)&amp;TypeOrValue.V}</DisplayString>
        <DisplayString IncludeView="arg0" Condition="Args.NumArgs==0"></DisplayString>
        <DisplayString IncludeView="arg0">{Args.Args[0]}{*this,view(arg1)}</DisplayString>
        <DisplayString IncludeView="arg1" Condition="Args.NumArgs==1"></DisplayString>
        <DisplayString IncludeView="arg1">, {Args.Args[1]}{*this,view(arg2)}</DisplayString>
        <DisplayString IncludeView="arg2" Condition="Args.NumArgs==2"></DisplayString>
        <DisplayString IncludeView="arg2">, {Args.Args[2]}, ...</DisplayString>
        <DisplayString IncludeView="arg0cpp" Condition="Args.NumArgs==0"></DisplayString>
        <DisplayString IncludeView="arg0cpp">{Args.Args[0],view(cpp)}{*this,view(arg1cpp)}</DisplayString>
        <DisplayString IncludeView="arg1cpp" Condition="Args.NumArgs==1"></DisplayString>
        <DisplayString IncludeView="arg1cpp">, {Args.Args[1],view(cpp)}{*this,view(arg2cpp)}</DisplayString>
        <DisplayString IncludeView="arg2cpp" Condition="Args.NumArgs==2"></DisplayString>
        <DisplayString IncludeView="arg2cpp">, {Args.Args[2],view(cpp)}, ...</DisplayString>
        <DisplayString IncludeView="cpp" Condition="Integer.Kind == clang::TemplateArgument::ArgKind::Pack">{*this,view(arg0cpp)}</DisplayString>
        <DisplayString Condition="Integer.Kind == clang::TemplateArgument::ArgKind::Pack">{*this,view(arg0)}</DisplayString>
        <DisplayString Condition="Integer.Kind == clang::TemplateArgument::ArgKind::Expression">{(clang::Expr *)TypeOrValue.V,view(cpp)na}</DisplayString>
        <DisplayString>{(clang::TemplateArgument::ArgKind)TypeOrValue.Kind,en}</DisplayString>
        <Expand>
            <Item Name="QualType" Condition="Integer.Kind == clang::TemplateArgument::ArgKind::Type">*(clang::QualType *)&amp;TypeOrValue.V</Item>
            <Item Name="Expression" Condition="Integer.Kind == clang::TemplateArgument::ArgKind::Expression">(clang::Expr *)TypeOrValue.V</Item>
            <ArrayItems Condition="Integer.Kind == clang::TemplateArgument::ArgKind::Pack">
                <Size>Args.NumArgs</Size>
                <ValuePointer>Args.Args</ValuePointer>
            </ArrayItems>
            <!-- TODO: Other kinds-->
        </Expand>
    </Type>
    <Type Name="clang::TemplateArgumentListInfo">
        <DisplayString IncludeView ="elt0" Condition="Arguments.Size == 0"></DisplayString>
        <DisplayString IncludeView ="elt0">{((TemplateArgumentLoc*)Arguments.BeginX)[0],view(cpp)}{*this,view(elt1)}</DisplayString>
        <DisplayString IncludeView ="elt1" Condition="Arguments.Size == 1"></DisplayString>
        <DisplayString IncludeView ="elt1">, {((TemplateArgumentLoc*)Arguments.BeginX)[1],view(cpp)}{*this,view(elt2)}</DisplayString>
        <DisplayString IncludeView ="elt2" Condition="Arguments.Size == 2"></DisplayString>
        <DisplayString IncludeView ="elt2">, {((TemplateArgumentLoc*)Arguments.BeginX)[2],view(cpp)}{*this,view(elt3)}</DisplayString>
        <DisplayString IncludeView ="elt3" Condition="Arguments.Size == 3"></DisplayString>
        <DisplayString IncludeView ="elt3">, {((TemplateArgumentLoc*)Arguments.BeginX)[3],view(cpp)}{*this,view(elt4)}</DisplayString>
        <DisplayString IncludeView ="elt4" Condition="Arguments.Size == 4"></DisplayString>
        <DisplayString IncludeView ="elt4">, ...</DisplayString>
        <DisplayString Condition="Arguments.Size == 0">empty</DisplayString>
        <DisplayString Condition="Arguments.Size != 0">&lt;{*this,view(elt0)}&gt;</DisplayString>
        <DisplayString>Uninitialized</DisplayString>
    </Type>
    <Type Name="clang::TemplateArgumentList">
        <DisplayString IncludeView="arg0" Condition="NumArguments==0"></DisplayString>
        <DisplayString IncludeView="arg0">{Arguments[0],view(cpp)}{*this,view(arg1)}</DisplayString>
        <DisplayString IncludeView="arg1" Condition="NumArguments==1"></DisplayString>
        <DisplayString IncludeView="arg1">, {Arguments[1],view(cpp)}{*this,view(arg2)}</DisplayString>
        <DisplayString IncludeView="arg2" Condition="NumArguments==2"></DisplayString>
        <DisplayString IncludeView="arg2">, {Arguments[1],view(cpp)}, ...</DisplayString>
        <DisplayString>&lt;{*this,view(arg0)}&gt;</DisplayString>
        <Expand>
            <Item Name="NumArguments">NumArguments</Item>
            <ArrayItems>
                <Size>NumArguments</Size>
                <ValuePointer>Arguments</ValuePointer>
            </ArrayItems>
        </Expand>
    </Type>
    <Type Name="llvm::ArrayRef&lt;clang::TemplateArgument&gt;">
        <DisplayString IncludeView="arg0" Condition="Length==0"></DisplayString>
        <DisplayString IncludeView="arg0">{Data[0],view(cpp)}{*this,view(arg1)}</DisplayString>
        <DisplayString IncludeView="arg1" Condition="Length==1"></DisplayString>
        <DisplayString IncludeView="arg1">, {Data[1],view(cpp)}{*this,view(arg2)}</DisplayString>
        <DisplayString IncludeView="arg2" Condition="Length==2"></DisplayString>
        <DisplayString IncludeView="arg2">, {Data[2],view(cpp)}, ...</DisplayString>
        <DisplayString>&lt;{*this,view(arg0)}&gt;</DisplayString>
        <Expand>
            <Item Name="Length">Length</Item>
            <Synthetic Name="Data">
                <Expand>
                    <ArrayItems>
                        <Size>Length</Size>
                        <ValuePointer>Data</ValuePointer>
                    </ArrayItems>
                </Expand>
            </Synthetic>
        </Expand>
    </Type>
    <Type Name="clang::MultiLevelTemplateArgumentList">
        <DisplayString IncludeView="level0" Condition="(llvm::ArrayRef&lt;clang::TemplateArgument&gt; *)TemplateArgumentLists.EndX - (llvm::ArrayRef&lt;clang::TemplateArgument&gt; *)TemplateArgumentLists.BeginX==0"></DisplayString>
        <DisplayString IncludeView="level0">{((llvm::ArrayRef&lt;clang::TemplateArgument&gt; *)TemplateArgumentLists.BeginX)[0],view(cpp)}{*this,view(level1)}</DisplayString>
        <DisplayString IncludeView="level1" Condition="(llvm::ArrayRef&lt;clang::TemplateArgument&gt; *)TemplateArgumentLists.EndX - (llvm::ArrayRef&lt;clang::TemplateArgument&gt; *)TemplateArgumentLists.BeginX==1"></DisplayString>
        <DisplayString IncludeView="level1">::{((llvm::ArrayRef&lt;clang::TemplateArgument&gt; *)TemplateArgumentLists.BeginX)[1],view(cpp)}{*this,view(level2)}</DisplayString>
        <DisplayString IncludeView="level2" Condition="(llvm::ArrayRef&lt;clang::TemplateArgument&gt; *)TemplateArgumentLists.EndX - (llvm::ArrayRef&lt;clang::TemplateArgument&gt; *)TemplateArgumentLists.BeginX==2"></DisplayString>
        <DisplayString IncludeView="level2">::{((llvm::ArrayRef&lt;clang::TemplateArgument&gt; *)TemplateArgumentLists.BeginX)[2],view(cpp)}, ...</DisplayString>
        <DisplayString>{*this,view(level0)}</DisplayString>
        <Expand>
            <Item Name="TemplateList">TemplateArgumentLists</Item>
        </Expand>
    </Type>
    <Type Name="clang::ParsedTemplateArgument">
        <DisplayString Condition="Kind==clang::ParsedTemplateArgument::Type" IncludeView="cpp">{(clang::QualType *)Arg,view(cpp)na}</DisplayString>
        <DisplayString Condition="Kind==clang::ParsedTemplateArgument::Type">{*(clang::QualType *)Arg}</DisplayString>
        <DisplayString Condition="Kind==clang::ParsedTemplateArgument::NonType">{*(clang::Expr *)Arg}</DisplayString>
        <DisplayString Condition="Kind==clang::ParsedTemplateArgument::Template">{*(clang::TemplateName *)Arg</DisplayString>
        <Expand>
            <Item Name="Kind">Kind,en</Item>
            <Item Name="Arg" Condition="Kind==clang::ParsedTemplateArgument::Type">(clang::QualType *)Arg</Item>
            <Item Name="Arg" Condition="Kind==clang::ParsedTemplateArgument::NonType">(clang::Expr *)Arg</Item>
            <Item Name="Arg" Condition="Kind==clang::ParsedTemplateArgument::Template">(clang::TemplateName *)Arg</Item>
        </Expand>
    </Type>


    <Type Name="clang::TemplateIdAnnotation">
        <DisplayString IncludeView="arg0" Condition="NumArgs==0"></DisplayString>
        <DisplayString IncludeView="arg0">{(ParsedTemplateArgument *)(this+1),view(cpp)na}{this,view(arg1)na}</DisplayString>
        <DisplayString IncludeView="arg1" Condition="NumArgs==1"></DisplayString>
        <DisplayString IncludeView="arg1">, {((ParsedTemplateArgument *)(this+1))+1,view(cpp)na}{this,view(arg2)na}</DisplayString>
        <DisplayString IncludeView="arg2" Condition="NumArgs==2"></DisplayString>
        <DisplayString IncludeView="arg1">, ...</DisplayString>
        <DisplayString>{Name,na}&lt;{this,view(arg0)na}&gt;</DisplayString>
        <Expand>
            <Item Name="Name">Name</Item>
            <Synthetic Name="Arguments">
                <DisplayString>{this,view(arg0)na}</DisplayString>
                <Expand>
                    <ArrayItems>
                        <Size>NumArgs</Size>
                        <ValuePointer>(ParsedTemplateArgument *)(this+1)</ValuePointer>
                    </ArrayItems>
                </Expand>
            </Synthetic>
            <Item Name="Operator">Operator</Item>
        </Expand>
    </Type>
    <Type Name="clang::Token">
        <DisplayString Condition="Kind == clang::tok::annot_template_id">{{annot_template_id ({(clang::TemplateIdAnnotation *)(PtrData),na})}}</DisplayString>
        <DisplayString Condition="Kind == clang::tok::identifier">{{Identifier ({(clang::IdentifierInfo *)(PtrData),na})}}</DisplayString>
        <DisplayString>{(clang::tok::TokenKind)Kind,en}</DisplayString>
    </Type>
    <Type Name="clang::Lexer">
        <DisplayString>{BufferPtr,nasb}</DisplayString>
    </Type>
    <Type Name="clang::Preprocessor::IncludeStackInfo">
        <DisplayString Condition="TheLexer._Mypair._Myval2 != 0">{TheLexer._Mypair._Myval2,na}</DisplayString>
        <DisplayString Condition="TheTokenLexer._Mypair._Myval2 != 0">Expanding Macro: {TheTokenLexer._Mypair._Myval2,na}</DisplayString>
        <DisplayString></DisplayString>
    </Type>
    <Type Name="clang::Preprocessor">
        <DisplayString IncludeView="cached" Condition="CachedLexPos &lt; CachedTokens.Size">
            [{(Token *)(CachedTokens.BeginX) + CachedLexPos,na}] {IncludeMacroStack._Mypair._Myval2._Mylast - 1,na}
        </DisplayString>
        <DisplayString IncludeView="cached"> {IncludeMacroStack._Mypair._Myval2._Mylast - 1,na}</DisplayString>
        <DisplayString Condition="CurLexer._Mypair._Myval2 != 0">{CurLexer._Mypair._Myval2,na}</DisplayString>
        <DisplayString Condition="CurTokenLexer._Mypair._Myval2 != 0">Expanding Macro: {CurTokenLexer._Mypair._Myval2,na}</DisplayString>
        <!-- Can't use CurLexerKind because natvis sees the type rather than the variable -->
        <DisplayString Condition="IncludeMacroStack._Mypair._Myval2._Mylast - IncludeMacroStack._Mypair._Myval2._Myfirst">
            {this,view(cached)}
        </DisplayString>
        <DisplayString>CLK_LexAfterModuleImport</DisplayString>
    </Type>
    <Type Name="clang::Parser">
        <DisplayString>[{Tok}] {PP,na}</DisplayString>
    </Type>
    <Type Name="clang::LambdaIntroducer::LambdaCapture">
        <DisplayString Condition="Kind == LCK_This">this</DisplayString>
        <DisplayString Condition="Kind == LCK_StarThis">*this</DisplayString>
        <DisplayString Condition="Kind == LCK_ByCopy">{Id}</DisplayString>
        <DisplayString Condition="Kind == LCK_ByRef">&amp;{Id}</DisplayString>
        <DisplayString>No visualizer for {Kind}</DisplayString>
    </Type>
    <Type Name="clang::LambdaIntroducer">
        <DisplayString IncludeView="default" Condition="Default==LCD_None"></DisplayString>
        <DisplayString IncludeView="default" Condition="Default==LCD_ByCopy">=,</DisplayString>
        <DisplayString IncludeView="default" Condition="Default==LCD_ByRef">&amp;,</DisplayString>
        <DisplayString IncludeView="capture0" Condition="Captures.Size==0"></DisplayString>
        <DisplayString IncludeView="capture0">{(LambdaCapture *)(Captures.BeginX),na}{this,view(capture1)na}</DisplayString>
        <DisplayString IncludeView="capture1" Condition="Captures.Size==1"></DisplayString>
        <DisplayString IncludeView="capture1">,{(LambdaCapture *)(Captures.BeginX)+1,na}{this,view(capture2)na}</DisplayString>
        <DisplayString IncludeView="capture2" Condition="Captures.Size==2"></DisplayString>
        <DisplayString IncludeView="capture2">,{(LambdaCapture *)(Captures.BeginX)+2,na}{this,view(capture3)na}</DisplayString>
        <DisplayString IncludeView="capture3" Condition="Captures.Size==3"></DisplayString>
        <DisplayString IncludeView="capture3">,...</DisplayString>
        <DisplayString>[{this,view(default)na}{this,view(capture0)na}]</DisplayString>
    </Type>
    <Type Name="clang::DeclSpec">
        <DisplayString IncludeView="extra" Condition="TypeSpecType == TST_typename || TypeSpecType == TST_typeofType || TypeSpecType == TST_underlying_type || TypeSpecType == TST_atomic">
            , [{TypeRep}]
        </DisplayString>
        <DisplayString IncludeView="extra" Condition="TypeSpecType == TST_typeofExpr || TypeSpecType == TST_decltype">
            , [{ExprRep}]
        </DisplayString>
        <DisplayString IncludeView="extra" Condition="TypeSpecType == TST_enum || TypeSpecType == TST_struct || TypeSpecType == TST_interface || TypeSpecType == TST_union || TypeSpecType == TST_class">
            , [{DeclRep}]
        </DisplayString>
        <DisplayString IncludeView="extra"></DisplayString>
        <DisplayString>[{(clang::DeclSpec::SCS)StorageClassSpec,en}], [{(clang::TypeSpecifierType)TypeSpecType,en}]{this,view(extra)na}</DisplayString>
        <Expand>
            <Item Name="StorageClassSpec">(clang::DeclSpec::SCS)StorageClassSpec</Item>
            <Item Name="TypeSpecType">(clang::TypeSpecifierType)TypeSpecType</Item>
            <Item Name="TypeRep" Condition="TypeSpecType == TST_typename || TypeSpecType == TST_typeofType || TypeSpecType == TST_underlying_type || TypeSpecType == TST_atomic">
                TypeRep
            </Item>
            <Item Name="ExprRep" Condition="TypeSpecType == TST_typeofExpr || TypeSpecType == TST_decltype">
                ExprRep
            </Item>
            <Item Name="DeclRep" Condition="TypeSpecType == TST_enum || TypeSpecType == TST_struct || TypeSpecType == TST_interface || TypeSpecType == TST_union || TypeSpecType == TST_class">
                DeclRep
            </Item>

        </Expand>
    </Type>
    <Type Name="clang::PragmaHandler">
        <DisplayString>{Name,s}</DisplayString>
    </Type>
    <Type Name="clang::FileEntry">
        <DisplayString>{RealPathName,s}</DisplayString>
    </Type>
    <Type Name="clang::DirectoryEntry">
        <DisplayString>{Name,s}</DisplayString>
    </Type>
    <Type Name="clang::SourceLocation">
        <DisplayString Condition="ID == 0">invalid</DisplayString>
        <DisplayString Condition="ID != 0">{ID}</DisplayString>
        <Expand HideRawView="true"/>
    </Type>

    <Type Name="clang::UnqualifiedId">
        <DisplayString Condition="Kind==UnqualifiedIdKind::IK_Identifier">[IK_Identifier] {*Identifier}</DisplayString>
        <DisplayString Condition="Kind==UnqualifiedIdKind::IK_OperatorFunctionId">[IK_OperatorFunctionId] {OperatorFunctionId}</DisplayString>
        <DisplayString Condition="Kind==UnqualifiedIdKind::IK_ConversionFunctionId">[IK_ConversionFunctionId] {ConversionFunctionId}</DisplayString>
        <DisplayString Condition="Kind==UnqualifiedIdKind::IK_ConstructorName">[IK_ConstructorName] {ConstructorName}</DisplayString>
        <DisplayString Condition="Kind==UnqualifiedIdKind::IK_DestructorName">[IK_DestructorName] {DestructorName}</DisplayString>
        <DisplayString Condition="Kind==UnqualifiedIdKind::IK_DeductionGuideName">[IK_DeductionGuideName] {TemplateName}</DisplayString>
        <DisplayString Condition="Kind==UnqualifiedIdKind::IK_TemplateId">[IK_TemplateId] {TemplateId}</DisplayString>
        <DisplayString Condition="Kind==UnqualifiedIdKind::IK_ConstructorTemplateId">[IK_ConstructorTemplateId] {TemplateId}</DisplayString>
        <DisplayString>Kind</DisplayString>
        <Expand>
            <ExpandedItem Condition="Kind==UnqualifiedIdKind::IK_Identifier">Identifier</ExpandedItem>
            <ExpandedItem Condition="Kind==UnqualifiedIdKind::IK_OperatorFunctionId">OperatorFunctionId</ExpandedItem>
            <ExpandedItem Condition="Kind==UnqualifiedIdKind::IK_ConversionFunctionId">ConversionFunctionId</ExpandedItem>
            <ExpandedItem Condition="Kind==UnqualifiedIdKind::IK_ConstructorName">ConstructorName</ExpandedItem>
            <ExpandedItem Condition="Kind==UnqualifiedIdKind::IK_DestructorName">DestructorName</ExpandedItem>
            <ExpandedItem Condition="Kind==UnqualifiedIdKind::IK_DeductionGuideName">TemplateName</ExpandedItem>
            <ExpandedItem Condition="Kind==UnqualifiedIdKind::IK_TemplateId">TemplateId</ExpandedItem>
            <ExpandedItem Condition="Kind==UnqualifiedIdKind::IK_ConstructorTemplateId">TemplateId</ExpandedItem>
        </Expand>
    </Type>
    <Type Name="clang::OpaquePtr&lt;*&gt;">
        <DisplayString>{*($T1*)&amp;Ptr}</DisplayString>
        <Expand>
            <ExpandedItem>($T1*)&amp;Ptr</ExpandedItem>
        </Expand>
    </Type>
    <Type Name="clang::UnionOpaquePtr&lt;*&gt;">
        <DisplayString>{($T1 *)Ptr}</DisplayString>
        <Expand>
            <ExpandedItem>($T1 *)Ptr</ExpandedItem>
        </Expand>
    </Type>
    <Type Name="clang::Stmt">
        <DisplayString>{(clang::Stmt::StmtClass)StmtBits.sClass,en}</DisplayString>
        <Expand>
            <Item Name="Class">(clang::Stmt::StmtClass)StmtBits.sClass,en</Item>
        </Expand>
    </Type>
    <Type Name="clang::Expr">
        <DisplayString>Expression of class {(clang::Stmt::StmtClass)StmtBits.sClass,en} and type {TR,view(cpp)}</DisplayString>
    </Type>
    <Type Name="clang::TemplateParameterList">
        <DisplayString IncludeView="parm0" Condition="NumParams==0"></DisplayString>
        <DisplayString IncludeView="parm0">{*((NamedDecl **)(this+1))[0],view(name)}{*this,view(parm1)}</DisplayString>
        <DisplayString IncludeView="parm1" Condition="NumParams==1"></DisplayString>
        <DisplayString IncludeView="parm1">, {*((NamedDecl **)(this+1))[1],view(name)}{*this,view(parm2)}</DisplayString>
        <DisplayString IncludeView="parm2" Condition="NumParams==2"></DisplayString>
        <DisplayString IncludeView="parm2">, {*((NamedDecl **)(this+1))[2],view(name)}{*this,view(parm3)}</DisplayString>
        <DisplayString IncludeView="parm3" Condition="NumParams==3"></DisplayString>
        <DisplayString IncludeView="parm3">, {*((NamedDecl **)(this+1))[3],view(name)}{*this,view(parm4)}</DisplayString>
        <DisplayString IncludeView="parm4" Condition="NumParams==4"></DisplayString>
        <DisplayString IncludeView="parm4">, {*((NamedDecl **)(this+1))[4],view(name)}{*this,view(parm5)}</DisplayString>
        <DisplayString IncludeView="parm5" Condition="NumParams==5"></DisplayString>
        <DisplayString IncludeView="parm5">, /* Expand for more params */</DisplayString>
        <DisplayString>&lt;{*this,view(parm0)}&gt;</DisplayString>
        <Expand>
            <ArrayItems>
                <Size>NumParams</Size>
                <ValuePointer>(NamedDecl **)(this+1),na</ValuePointer>
            </ArrayItems>
        </Expand>
    </Type>




    <!-- ================================================================================================ -->


    <Type Name="clang::IdentifierInfo">
        <DisplayString Condition="Entry != nullptr">{Entry-&gt;key_data(),[Entry-&gt;key_size()]nas8b}</DisplayString>
        <DisplayString></DisplayString>
        <Expand>
            <Item Name="Kind">(clang::tok::TokenKind)TokenID,en</Item>
            <Item Name="Name" Condition="Entry != nullptr">Entry-&gt;key_data(),[Entry-&gt;key_size()]nas8b</Item>
        </Expand>
    </Type>

    <Type Name="clang::DeclarationName">
        <Intrinsic Category="Data" Name="get_ptr" Expression="(void*)(Ptr &amp; ~PtrMask)"/>
        <Intrinsic Category="Data" Name="get_stored_kind" Expression="Ptr &amp; PtrMask"/>
        <Intrinsic Category="Data" Name="get_name_kind" Expression="(NameKind)(get_stored_kind() != StoredDeclarationNameExtra ?
            get_stored_kind() : UncommonNameKindOffset + ((detail::DeclarationNameExtra*)get_ptr())-&gt;get_kind())"/>

        <DisplayString Condition="! Ptr"></DisplayString>
        <DisplayString Condition="get_stored_kind() == StoredIdentifier">{*(IdentifierInfo*)get_ptr(),na}</DisplayString>
        <DisplayString Condition="get_stored_kind() == StoredObjCZeroArgSelector">{*(IdentifierInfo*)get_ptr(),na} (0 argument selector)</DisplayString>
        <DisplayString Condition="get_stored_kind() == StoredObjCOneArgSelector">{*(IdentifierInfo*)get_ptr(),na} (1 argument selector)</DisplayString>
        <DisplayString Condition="get_stored_kind() == StoredCXXConstructorName">constructor {*(detail::CXXSpecialNameExtra*)get_ptr(),na}</DisplayString>
        <DisplayString Condition="get_stored_kind() == StoredCXXDestructorName">destructor {*(detail::CXXSpecialNameExtra*)get_ptr(),na}</DisplayString>
        <DisplayString Condition="get_stored_kind() == StoredCXXConversionFunctionName">conversion function {*(detail::CXXSpecialNameExtra*)get_ptr(),na}</DisplayString>
        <DisplayString Condition="get_stored_kind() == StoredCXXOperatorName">operator {*(detail::CXXOperatorIdName*)get_ptr(),na}</DisplayString>
        <DisplayString Condition="get_name_kind() == CXXDeductionGuideName">deduction guide {*(detail::CXXDeductionGuideNameExtra*)get_ptr(),na}</DisplayString>
        <DisplayString Condition="get_name_kind() == CXXLiteralOperatorName">literal operator {*(detail::CXXLiteralOperatorIdName*)get_ptr(),na}</DisplayString>
        <DisplayString Condition="get_name_kind() == CXXUsingDirective">using directive</DisplayString>
        <DisplayString Condition="get_name_kind() == ObjCMultiArgSelector">multi-argument selector</DisplayString>
        <DisplayString></DisplayString>

        <Expand>
            <Item Name="Kind">get_name_kind(),en</Item>
            <Item Name="StoredKind">StoredNameKind(get_stored_kind()),en</Item>

            <Item Name="[identifier]" Condition="get_stored_kind() == StoredIdentifier">*(IdentifierInfo*)get_ptr(),na</Item>
            <Item Name="[selector]" Condition="get_stored_kind() == StoredObjCZeroArgSelector">*(IdentifierInfo*)get_ptr(),na</Item>
            <Item Name="[selector]" Condition="get_stored_kind() == StoredObjCOneArgSelector">*(IdentifierInfo*)get_ptr(),na</Item>
            <Item Name="[constructor]" Condition="get_stored_kind() == StoredCXXConstructorName">*(detail::CXXSpecialNameExtra*)get_ptr(),na</Item>
            <Item Name="[destructor]" Condition="get_stored_kind() == StoredCXXDestructorName">*(detail::CXXSpecialNameExtra*)get_ptr(),na</Item>
            <Item Name="[conversion function]" Condition="get_stored_kind() == StoredCXXConversionFunctionName">*(detail::CXXSpecialNameExtra*)get_ptr(),na</Item>
            <Item Name="[operator]" Condition="get_stored_kind() == StoredCXXOperatorName">*(detail::CXXOperatorIdName*)get_ptr(),na</Item>
            <Item Name="[deduction guide]" Condition="get_name_kind() == CXXDeductionGuideName">*(detail::CXXDeductionGuideNameExtra*)get_ptr(),na</Item>
            <Item Name="[literal operator]" Condition="get_name_kind() == CXXLiteralOperatorName">*(detail::CXXLiteralOperatorIdName*)get_ptr(),na</Item>
            <Item Name="[selector]" Condition="get_name_kind() == ObjCMultiArgSelector">*(detail::DeclarationNameExtra*)get_ptr(),na</Item>

            <!--
            <Item Name="[extra]" Condition="get_stored_kind() == StoredDeclarationNameExtra">(detail::DeclarationNameExtra*)get_ptr(),na</Item>
            -->
        </Expand>
    </Type>

    <Type Name="clang::detail::DeclarationNameExtra">
        <Intrinsic Category="Data" Name="get_kind" Expression="static_cast&lt;ExtraKind&gt;(
                ExtraKindOrNumArgs &gt; (unsigned)ObjCMultiArgSelector ?
                    (unsigned)ObjCMultiArgSelector : ExtraKindOrNumArgs)"/>
        <!-- KRYSTIAN NOTE: only used for ObjCMultiArgSelector, which we don't care about -->
        <Intrinsic Category="Data" Name="get_num_args" Expression="ExtraKindOrNumArgs &lt; (unsigned)ObjCMultiArgSelector ?
            0 : ExtraKindOrNumArgs - (unsigned)ObjCMultiArgSelector"/>

        <DisplayString>ExtraKind = {get_kind(),en}</DisplayString>
        <Expand>
            <Item Name="ExtraKind">get_kind(),en</Item>
        </Expand>
    </Type>



    <Type Name="clang::detail::CXXDeductionGuideNameExtra">
        <Expand>
            <ExpandedItem>*(detail::DeclarationNameExtra*)this,nd</ExpandedItem>
            <Item Name="Template">Template</Item>
            <Item Name="FETokenInfo">FETokenInfo</Item>
        </Expand>
    </Type>

    <Type Name="clang::detail::CXXLiteralOperatorIdName">
        <Expand>
            <ExpandedItem>*(detail::DeclarationNameExtra*)this,nd</ExpandedItem>
            <Item Name="Identifier">ID</Item>
            <Item Name="FETokenInfo">FETokenInfo</Item>
        </Expand>
    </Type>

    <Type Name="clang::detail::CXXSpecialNameExtra">
        <DisplayString>{Type}</DisplayString>
        <Expand>
            <Item Name="Type">Type</Item>
            <Item Name="FETokenInfo">FETokenInfo</Item>
        </Expand>
    </Type>

    <Type Name="clang::detail::CXXOperatorIdName">
        <DisplayString>{Kind,en}</DisplayString>
        <Expand>
            <Item Name="Operator">Kind,en</Item>
            <Item Name="FETokenInfo">FETokenInfo</Item>
        </Expand>
    </Type>

    <Type Name="clang::DeclarationNameInfo">
        <DisplayString>{Name}</DisplayString>
    </Type>

    <Type Name="clang::AssumedTemplateStorage">
        <DisplayString>{Name}</DisplayString>
    </Type>

    <Type Name="clang::UncommonTemplateNameStorage::BitsTag">
        <DisplayString>Kind={(UncommonTemplateNameStorage::Kind)Kind,en}, Size={Size}</DisplayString>
        <Expand>
            <Item Name="Kind">(UncommonTemplateNameStorage::Kind)Kind</Item>
            <Item Name="Size">Size</Item>
        </Expand>
    </Type>

    <Type Name="clang::UncommonTemplateNameStorage">
        <DisplayString IncludeView="cmn">{Bits},</DisplayString>
        <DisplayString Condition="Bits.Kind==UncommonTemplateNameStorage::Overloaded">{this,view(cmn)na},{(OverloadedTemplateStorage*)this,na}</DisplayString>
        <DisplayString Condition="Bits.Kind==UncommonTemplateNameStorage::Assumed">{this,view(cmn)na},{(AssumedTemplateStorage*)this,na}</DisplayString>
        <DisplayString Condition="Bits.Kind==UncommonTemplateNameStorage::SubstTemplateTemplateParm">{this,view(cmn)na},{(SubstTemplateTemplateParmStorage*)this,na}</DisplayString>
        <DisplayString Condition="Bits.Kind==UncommonTemplateNameStorage::SubstTemplateTemplateParmPack">{this,view(cmn)na},{(SubstTemplateTemplateParmPackStorage*)this,na}</DisplayString>
        <DisplayString>{this,view(cmn)na}</DisplayString>
        <Expand>
            <Item Name="Bits">Bits</Item>
            <ExpandedItem Condition="Bits.Kind==UncommonTemplateNameStorage::Overloaded">(OverloadedTemplateStorage*)this</ExpandedItem>
            <ExpandedItem Condition="Bits.Kind==UncommonTemplateNameStorage::Assumed">(AssumedTemplateStorage*)this</ExpandedItem>
            <ExpandedItem Condition="Bits.Kind==UncommonTemplateNameStorage::SubstTemplateTemplateParm">(SubstTemplateTemplateParmStorage*)this</ExpandedItem>
            <ExpandedItem Condition="Bits.Kind==UncommonTemplateNameStorage::SubstTemplateTemplateParmPack">(SubstTemplateTemplateParmPackStorage*)this</ExpandedItem>
        </Expand>
    </Type>

    <Type Name="clang::TemplateName">
        <DisplayString IncludeView="cpp">{Storage,view(cpp)na}</DisplayString>
        <DisplayString>{Storage,na}</DisplayString>
        <Expand>
            <ExpandedItem>Storage</ExpandedItem>
        </Expand>
    </Type>

    <Type Name="clang::NestedNameSpecifier">
        <DisplayString Condition="!Specifier"></DisplayString>
        <DisplayString Condition="((*(uintptr_t *)Prefix.Value.Data&gt;&gt;1)&amp;3) == 0">{(IdentifierInfo*)Specifier,view(cpp)na}::</DisplayString>
        <DisplayString Condition="((*(uintptr_t *)Prefix.Value.Data&gt;&gt;1)&amp;3) == 1">{(NamedDecl*)Specifier,view(cpp)na}::</DisplayString>
        <DisplayString Condition="((*(uintptr_t *)Prefix.Value.Data&gt;&gt;1)&amp;3) == 2">{(Type*)Specifier,view(cpp)na}::</DisplayString>
        <Expand>
            <Item Name="Kind">(NestedNameSpecifier::StoredSpecifierKind)((*(uintptr_t *)Prefix.Value.Data&gt;&gt;1)&amp;3)</Item>
        </Expand>
    </Type>


    <!-- ================================================================================================ -->

    <!--
    <Type Name="clang::Type">
        <Intrinsic Name="is_canonical" Expression="CanonicalType.Value.get_void_ptr() == this" />

        <!- To visualize clang::Types, we need to look at TypeBits.TC to determine the actual
         type subclass and manually dispatch accordingly (Visual Studio can't identify the real type
         because clang::Type has no virtual members hence no RTTI).

         Views:
           "cmn": Visualization that is common to all clang::Type subclasses
           "poly": Visualization that is specific to the actual clang::Type subclass. The subtype-specific
                   <DisplayString> is typically as C++-like as possible (like in dump()) with <Expand>
                   containing all the gory details.
           "cpp": Only occasionally used when we need to distinguish between an ordinary view and a C++-like view.
        ->
        <DisplayString IncludeView="cmn" Condition="TypeBits.TC==clang::LocInfoType::LocInfo">LocInfoType</DisplayString>
        <DisplayString IncludeView="cmn">{(clang::Type::TypeClass)TypeBits.TC, en}Type</DisplayString>
        <!- Dispatch to visualizers for the actual Type subclass ->
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::Builtin" IncludeView="poly">{*(clang::BuiltinType *)this}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::Pointer" IncludeView="poly">{*(clang::PointerType *)this}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::Paren" IncludeView="poly">{*(clang::ParenType *)this}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::BitInt" IncludeView="poly">{(clang::BitIntType *)this}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::LValueReference" IncludeView="poly">{*(clang::LValueReferenceType *)this}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::RValueReference" IncludeView="poly">{*(clang::RValueReferenceType *)this}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::ConstantArray" IncludeView="poly">{(clang::ConstantArrayType *)this,na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::ConstantArray" IncludeView="left">{(clang::ConstantArrayType *)this,view(left)na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::ConstantArray" IncludeView="right">{(clang::ConstantArrayType *)this,view(right)na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::VariableArray" IncludeView="poly">{(clang::VariableArrayType *)this,na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::VariableArray" IncludeView="left">{(clang::VariableArrayType *)this,view(left)na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::VariableArray" IncludeView="right">{(clang::VariableArrayType *)this,view(right)na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::IncompleteArray" IncludeView="poly">{(clang::IncompleteArrayType *)this,na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::IncompleteArray" IncludeView="left">{(clang::IncompleteArrayType *)this,view(left)na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::IncompleteArray" IncludeView="right">{(clang::IncompleteArrayType *)this,view(right)na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::Typedef" IncludeView="poly">{(clang::TypedefType *)this,na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::Typedef" IncludeView="cpp">{(clang::TypedefType *)this,view(cpp)na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::Attributed" IncludeView="poly">{*(clang::AttributedType *)this}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::Decayed" IncludeView="poly">{(clang::DecayedType *)this,na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::Decayed" IncludeView="left">{(clang::DecayedType *)this,view(left)na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::Decayed" IncludeView="right">{(clang::DecayedType *)this,view(right)na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::Elaborated" IncludeView="poly">{(clang::ElaboratedType *)this,na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::Elaborated" IncludeView="left">{(clang::ElaboratedType *)this,view(left)na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::Elaborated" IncludeView="right">{(clang::ElaboratedType *)this,view(right)na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::TemplateTypeParm" IncludeView="poly">{*(clang::TemplateTypeParmType *)this}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::TemplateTypeParm" IncludeView="cpp">{*(clang::TemplateTypeParmType *)this,view(cpp)}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::SubstTemplateTypeParm" IncludeView="poly">{*(clang::SubstTemplateTypeParmType *)this}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::Record" IncludeView="poly">{*(clang::RecordType *)this}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::Record" IncludeView="cpp">{*(clang::RecordType *)this,view(cpp)}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::FunctionProto" IncludeView="poly">{(clang::FunctionProtoType *)this,na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::FunctionProto" IncludeView="left">{(clang::FunctionProtoType *)this,view(left)na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::FunctionProto" IncludeView="right">{(clang::FunctionProtoType *)this,view(right)na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::TemplateSpecialization" IncludeView="poly">{*(clang::TemplateSpecializationType *)this}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::DeducedTemplateSpecialization" IncludeView="poly">{*(clang::DeducedTemplateSpecializationType *)this}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::DeducedTemplateSpecialization" IncludeView="cpp">{*(clang::DeducedTemplateSpecializationType *)this,view(cpp)}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::InjectedClassName" IncludeView="poly">{*(clang::InjectedClassNameType *)this}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::DependentName" IncludeView="poly">{*(clang::DependentNameType *)this}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::Type::TypeClass::PackExpansion" IncludeView="poly">{*(clang::PackExpansionType *)this}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::LocInfoType::LocInfo" IncludeView="poly">{(clang::LocInfoType *)this,na}</DisplayString>
        <DisplayString Condition="TypeBits.TC==clang::LocInfoType::LocInfo" IncludeView="cpp">{(clang::LocInfoType *)this,view(cpp)na}</DisplayString>
        <DisplayString IncludeView="cpp">{this,view(poly)na}</DisplayString>
        <DisplayString IncludeView="left">{*this,view(cpp)}</DisplayString>
        <DisplayString IncludeView="right"></DisplayString>
        <DisplayString IncludeView="poly">No visualizer yet for {(clang::Type::TypeClass)TypeBits.TC,en}Type</DisplayString>
        <!- Not yet implemented Type subclass ->
        <DisplayString IncludeView="Dependence" Condition="TypeBits.Dependence">Dependence{" ",en}</DisplayString>
        <DisplayString IncludeView="Dependence"></DisplayString>
        <DisplayString IncludeView="Cache" Condition="TypeBits.CacheValid &amp;&amp; TypeBits.CachedLocalOrUnnamed">CachedLinkage: {(clang::Linkage)TypeBits.CachedLinkage,en} CachedLocalOrUnnamed</DisplayString>
        <DisplayString IncludeView="Cache" Condition="TypeBits.CacheValid &amp;&amp; !TypeBits.CachedLocalOrUnnamed">CachedLinkage: {(clang::Linkage)TypeBits.CachedLinkage,en}{" ",sb}</DisplayString>
        <DisplayString IncludeView="Cache"></DisplayString>
        <DisplayString IncludeView="FromAST" Condition="TypeBits.FromAST">FromAST</DisplayString>
        <DisplayString IncludeView="FromAST"></DisplayString>
        <DisplayString IncludeView="flags" Condition="!TypeBits.Dependence &amp;&amp; !TypeBits.CacheValid &amp;&amp; !TypeBits.FromAST">
            No TypeBits set beyond TypeClass
        </DisplayString>
        <DisplayString IncludeView="flags">{*this, view(Dependence)}{*this, view(Cache)}{*this, view(FromAST)}</DisplayString>
        <DisplayString>{*this,view(cmn)}  {{{*this,view(poly)}}}</DisplayString>
        <Expand>
            <Item Name="TypeClass" IncludeView="cmn">(clang::Type::TypeClass)TypeBits.TC</Item>
            <Item Name="Flags" IncludeView="cmn">this,view(flags)na</Item>
            <Item Name="Canonical" IncludeView="cmn">CanonicalType</Item>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::Builtin">*(clang::BuiltinType *)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::Pointer">*(clang::PointerType *)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::Paren">*(clang::ParenType*)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::BitInt">*(clang::BitIntType*)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::LValueReference">*(clang::LValueReferenceType *)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::RValueReference">*(clang::RValueReferenceType *)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::ConstantArray">(clang::ConstantArrayType *)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::VariableArray">(clang::VariableArrayType *)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::IncompleteArray">(clang::IncompleteArrayType *)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::Attributed">*(clang::AttributedType *)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::Decayed">(clang::DecayedType *)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::Elaborated">(clang::ElaboratedType *)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::TemplateTypeParm">(clang::TemplateTypeParmType *)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::SubstTemplateTypeParm">(clang::SubstTemplateTypeParmType *)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::Record">(clang::RecordType *)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::FunctionProto">(clang::FunctionProtoType *)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::TemplateSpecialization">(clang::TemplateSpecializationType *)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::DeducedTemplateSpecialization">(clang::DeducedTemplateSpecializationType *)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::InjectedClassName">(clang::InjectedClassNameType *)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::DependentName">(clang::DependentNameType *)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::Type::TypeClass::PackExpansion">(clang::PackExpansionType *)this</ExpandedItem>
            <ExpandedItem ExcludeView="cmn" Condition="TypeBits.TC==clang::LocInfoType::LocInfo">(clang::LocInfoType *)this</ExpandedItem>
        </Expand>
    </Type>
    -->
    <Type Name="clang::Type">
        <Intrinsic Category="Data" Name="is" Expression="(Type::TypeClass)TypeBits.TC == tc">
            <Parameter Type="Type::TypeClass" Name="tc"/>
        </Intrinsic>
        <Intrinsic Category="Data" Name="is_canonical" Expression="CanonicalType.get_common_ptr() == (ExtQualsTypeCommonBase*)this"/>

        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::Adjusted">(AdjustedType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::Decayed">(DecayedType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::ConstantArray">(ConstantArrayType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::DependentSizedArray">(DependentSizedArrayType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::IncompleteArray">(IncompleteArrayType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::VariableArray">(VariableArrayType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::Atomic">(AtomicType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::Attributed">(AttributedType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::BTFTagAttributed">(BTFTagAttributedType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::BitInt">(BitIntType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::BlockPointer">(BlockPointerType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::Builtin">(BuiltinType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::Complex">(ComplexType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::Decltype">(DecltypeType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::Auto">(AutoType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::DeducedTemplateSpecialization">(DeducedTemplateSpecializationType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::DependentAddressSpace">(DependentAddressSpaceType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::DependentBitInt">(DependentBitIntType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::DependentName">(DependentNameType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::DependentSizedExtVector">(DependentSizedExtVectorType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::DependentTemplateSpecialization">(DependentTemplateSpecializationType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::DependentVector">(DependentVectorType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::Elaborated">(ElaboratedType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::FunctionNoProto">(FunctionNoProtoType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::FunctionProto">(FunctionProtoType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::InjectedClassName">(InjectedClassNameType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::MacroQualified">(MacroQualifiedType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::ConstantMatrix">(ConstantMatrixType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::DependentSizedMatrix">(DependentSizedMatrixType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::MemberPointer">(MemberPointerType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::ObjCObjectPointer">(ObjCObjectPointerType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::ObjCObject">(ObjCObjectType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::ObjCInterface">(ObjCInterfaceType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::ObjCTypeParam">(ObjCTypeParamType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::PackExpansion">(PackExpansionType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::Paren">(ParenType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::Pipe">(PipeType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::Pointer">(PointerType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::LValueReference">(LValueReferenceType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::RValueReference">(RValueReferenceType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::SubstTemplateTypeParmPack">(SubstTemplateTypeParmPackType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::SubstTemplateTypeParm">(SubstTemplateTypeParmType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::Enum">(EnumType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::Record">(RecordType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::TemplateSpecialization">(TemplateSpecializationType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::TemplateTypeParm">(TemplateTypeParmType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::TypeOfExpr">(TypeOfExprType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::TypeOf">(TypeOfType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::Typedef">(TypedefType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::UnaryTransform">(UnaryTransformType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::UnresolvedUsing">(UnresolvedUsingType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::Using">(UsingType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::Vector">(VectorType*)this</MostDerivedType>
        <MostDerivedType Condition="(Type::TypeClass)TypeBits.TC == Type::ExtVector">(ExtVectorType*)this</MostDerivedType>

        <DisplayString Condition="is_canonical()">{(Type::TypeClass)TypeBits.TC,en} (canonical)</DisplayString>
        <DisplayString>{(Type::TypeClass)TypeBits.TC,en}</DisplayString>
        <Expand>
            <Item Name="Kind">(Type::TypeClass)TypeBits.TC,en</Item>
            <Item Name="[canonical]" Condition="! is_canonical()">CanonicalType</Item>
        </Expand>
    </Type>

    <!-- ================================================================================================ -->

    <!--
    <Type Name="clang::QualType">
        <DisplayString IncludeView="poly">{((clang::ExtQualsTypeCommonBase *)((*(uintptr_t *)Value.Value.Data) &amp; ~(uintptr_t)((1U &lt;&lt; clang::TypeAlignmentInBits) - 1U)))-&gt;BaseType,view(poly)}{*this,view(fastQuals)}</DisplayString>
        <DisplayString IncludeView="cpp">{((clang::ExtQualsTypeCommonBase *)((*(uintptr_t *)Value.Value.Data) &amp; ~(uintptr_t)((1U &lt;&lt; clang::TypeAlignmentInBits) - 1U)))-&gt;BaseType,view(cpp)}{*this,view(fastQuals)}</DisplayString>
        <DisplayString IncludeView="left">{((clang::ExtQualsTypeCommonBase *)((*(uintptr_t *)Value.Value.Data) &amp; ~(uintptr_t)((1U &lt;&lt; clang::TypeAlignmentInBits) - 1U)))-&gt;BaseType,view(left)}{*this,view(fastQuals)}</DisplayString>
        <DisplayString IncludeView="right">{((clang::ExtQualsTypeCommonBase *)((*(uintptr_t *)Value.Value.Data) &amp; ~(uintptr_t)((1U &lt;&lt; clang::TypeAlignmentInBits) - 1U)))-&gt;BaseType,view(right)}{*this,view(fastQuals)}</DisplayString>
        <!- For the Fast Qualifiers, it is simpler (and probably more efficient) just to list all 8 cases than create
          views for each qualifier. TODO: Non-fast qualifiers ->
        <DisplayString IncludeView="fastQuals" Condition="(((*(uintptr_t *)Value.Value.Data) &gt;&gt; 1) &amp; 7)==0"></DisplayString>
        <DisplayString IncludeView="fastQuals" Condition="(((*(uintptr_t *)Value.Value.Data) &gt;&gt; 1) &amp; 7)==1">{" ",sb}const</DisplayString>
        <DisplayString IncludeView="fastQuals" Condition="(((*(uintptr_t *)Value.Value.Data) &gt;&gt; 1) &amp; 7)==2">{" ",sb}restrict</DisplayString>
        <DisplayString IncludeView="fastQuals" Condition="(((*(uintptr_t *)Value.Value.Data) &gt;&gt; 1) &amp; 7)==3">{" ",sb}const restrict</DisplayString>
        <DisplayString IncludeView="fastQuals" Condition="(((*(uintptr_t *)Value.Value.Data) &gt;&gt; 1) &amp; 7)==4">{" ",sb}volatile</DisplayString>
        <DisplayString IncludeView="fastQuals" Condition="(((*(uintptr_t *)Value.Value.Data) &gt;&gt; 1) &amp; 7)==5">{" ",sb}const volatile</DisplayString>
        <DisplayString IncludeView="fastQuals" Condition="(((*(uintptr_t *)Value.Value.Data) &gt;&gt; 1) &amp; 7)==6">{" ",sb}volatile restrict</DisplayString>
        <DisplayString IncludeView="fastQuals" Condition="(((*(uintptr_t *)Value.Value.Data) &gt;&gt; 1) &amp; 7)==7">{" ",sb}const volatile restrict</DisplayString>
        <DisplayString IncludeView="fastQuals">Cannot visualize non-fast qualifiers</DisplayString>
        <DisplayString Condition="(*(uintptr_t *)Value.Value.Data) == 0">Null</DisplayString>
        <DisplayString>{((clang::ExtQualsTypeCommonBase *)((*(uintptr_t *)Value.Value.Data) &amp; ~(uintptr_t)((1U &lt;&lt; clang::TypeAlignmentInBits) - 1U)))-&gt;BaseType,na}{*this,view(fastQuals)}</DisplayString>
        <Expand>
            <Item Name="Fast Quals">*this,view(fastQuals)</Item>
            <ExpandedItem>((clang::ExtQualsTypeCommonBase *)((*(uintptr_t *)Value.Value.Data) &amp; ~(uintptr_t)((1U &lt;&lt; clang::TypeAlignmentInBits) - 1U)))-&gt;BaseType</ExpandedItem>
        </Expand>
    </Type>
    -->

    <Type Name="clang::QualType">
        <Intrinsic Category="Data" Name="is_null" Expression="Value.is_null()"/>
        <Intrinsic Category="Data" Name="get_common_ptr" Expression="(ExtQualsTypeCommonBase*)
            ((uintptr_t)Value.get_void_ptr() &amp; ~(uintptr_t)((1 &lt;&lt; clang::TypeAlignmentInBits) - 1))"/>
        <Intrinsic Category="Data" Name="get_type_ptr" Expression="is_null() ? nullptr : (Type*)(get_common_ptr()-&gt;BaseType)"/>
        <Intrinsic Category="Data" Name="is" Expression="! is_null() &amp;&amp; (Type::TypeClass)((Type*)get_common_ptr()-&gt;BaseType)-&gt;TypeBits.TC == tc">
            <Parameter Type="Type::TypeClass" Name="tc"/>
        </Intrinsic>

        <DisplayString Condition="is_null()">&lt;null&gt;</DisplayString>

        <DisplayString IncludeView="left" Condition="Value.get_int() == 0">{get_type_ptr(),view(left)na}</DisplayString>
        <DisplayString IncludeView="left" Condition="Value.get_int() == 1">const {get_type_ptr(),view(left)na}</DisplayString>
        <DisplayString IncludeView="left" Condition="Value.get_int() == 2">restrict {get_type_ptr(),view(left)na}</DisplayString>
        <DisplayString IncludeView="left" Condition="Value.get_int() == 3">const restrict {get_type_ptr(),view(left)na}</DisplayString>
        <DisplayString IncludeView="left" Condition="Value.get_int() == 4">volatile {get_type_ptr(),view(left)na}</DisplayString>
        <DisplayString IncludeView="left" Condition="Value.get_int() == 5">const volatile {get_type_ptr(),view(left)na}</DisplayString>
        <DisplayString IncludeView="left" Condition="Value.get_int() == 6">volatile restrict {get_type_ptr(),view(left)na}</DisplayString>
        <DisplayString IncludeView="left" Condition="Value.get_int() == 7">const volatile restrict {get_type_ptr(),view(left)na}</DisplayString>

        <DisplayString IncludeView="right">{get_type_ptr(),view(right)na}</DisplayString>

        <DisplayString Condition="Value.get_int() == 0">{get_type_ptr(),na}</DisplayString>
        <DisplayString Condition="Value.get_int() == 1">const {get_type_ptr(),na}</DisplayString>
        <DisplayString Condition="Value.get_int() == 2">restrict {get_type_ptr(),na}</DisplayString>
        <DisplayString Condition="Value.get_int() == 3">const restrict {get_type_ptr(),na}</DisplayString>
        <DisplayString Condition="Value.get_int() == 4">volatile {get_type_ptr(),na}</DisplayString>
        <DisplayString Condition="Value.get_int() == 5">const volatile {get_type_ptr(),na}</DisplayString>
        <DisplayString Condition="Value.get_int() == 6">volatile restrict {get_type_ptr(),na}</DisplayString>
        <DisplayString Condition="Value.get_int() == 7">const volatile restrict {get_type_ptr(),na}</DisplayString>

        <Expand>
            <Synthetic Name="[fast qualifiers]" Condition="Value.get_int()">
                <DisplayString Condition="Value.get_int() == 1">const</DisplayString>
                <DisplayString Condition="Value.get_int() == 2">restrict</DisplayString>
                <DisplayString Condition="Value.get_int() == 3">const restrict</DisplayString>
                <DisplayString Condition="Value.get_int() == 4">volatile</DisplayString>
                <DisplayString Condition="Value.get_int() == 5">const volatile</DisplayString>
                <DisplayString Condition="Value.get_int() == 6">volatile restrict</DisplayString>
                <DisplayString Condition="Value.get_int() == 7">const volatile restrict</DisplayString>
            </Synthetic>
            <Item Name="[type]" Condition="! is_null()">get_type_ptr(),na</Item>
        </Expand>
    </Type>

    <!-- ================================================================================================ -->

    <Type Name="clang::TypeSourceInfo">
        <DisplayString IncludeView="cpp">{Ty,view(cpp)}</DisplayString>
        <DisplayString>{Ty}</DisplayString>
        <Expand>
            <ExpandedItem>Ty</ExpandedItem>
        </Expand>
    </Type>
    <Type Name="clang::TypeLoc">
        <DisplayString>{(QualType *)&amp;Ty,na}</DisplayString>
        <Expand>
            <Item Name="Ty">(QualType *)&amp;Ty</Item>
            <Item Name="Data">Data</Item>
        </Expand>
    </Type>
    <Type Name="clang::TypeLocBuilder">
        <DisplayString Optional="true" Condition="LastTy.Value.Value==0">Not building anything</DisplayString>
        <DisplayString Optional="true">Building a {LastTy}</DisplayString>
    </Type>

    <!-- ================================================================================================ -->

    <!-- Builtin types that have C++ keywords are manually displayed as that keyword. Otherwise, just use the enum name -->
    <Type Name="clang::BuiltinType">
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::Void">void</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::Bool">bool</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::Char_U">char</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::UChar">unsigned char</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::WChar_U">wchar_t</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::Char16">char16_t</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::Char32">char32_t</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::UShort">unsigned short</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::UInt">unsigned int</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::ULong">unsigned long</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::ULongLong">unsigned long long</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::UInt128">__uint128_t</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::Char_S">char</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::SChar">signed char</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::WChar_S">wchar_t</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::Short">short</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::Int">int</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::Long">long</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::LongLong">long long</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::Int128">__int128_t</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::Half">__fp16</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::Float">float</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::Double">double</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::LongDouble">long double</DisplayString>
        <DisplayString Condition="BuiltinTypeBits.Kind==clang::BuiltinType::NullPtr">nullptr_t</DisplayString>
        <DisplayString>{(clang::BuiltinType::Kind)BuiltinTypeBits.Kind, en}</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::Type*)this,nd</ExpandedItem>
            <Item Name="BuiltinKind">(clang::BuiltinType::Kind)BuiltinTypeBits.Kind</Item>
        </Expand>
    </Type>

    <Type Name="clang::TemplateSpecializationType">
        <DisplayString IncludeView="arg0" Condition="TemplateSpecializationTypeBits.NumArgs==0"></DisplayString>
        <DisplayString IncludeView="arg0">{((clang::TemplateArgument *)(this+1))[0],view(cpp)}{*this,view(arg1)}</DisplayString>
        <DisplayString IncludeView="arg1" Condition="TemplateSpecializationTypeBits.NumArgs==1"></DisplayString>
        <DisplayString IncludeView="arg1">, {((clang::TemplateArgument *)(this+1))[1],view(cpp)}{*this,view(arg2)}</DisplayString>
        <DisplayString IncludeView="arg2" Condition="TemplateSpecializationTypeBits.NumArgs==2"></DisplayString>
        <DisplayString IncludeView="arg2">, {((clang::TemplateArgument *)(this+1))[2],view(cpp)}{*this,view(arg3)}</DisplayString>
        <DisplayString Condition="Template.Storage.get_int() == 0">
            {*((clang::TemplateDecl *)(Template.Storage.get_ptr()))->TemplatedDecl,view(cpp)}&lt;{*this,view(arg0)}&gt;
        </DisplayString>
        <DisplayString>Can't visualize this TemplateSpecializationType</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::Type*)this,nd</ExpandedItem>
            <Item Name="Template">Template.Storage</Item>
            <ArrayItems>
                <Size>TemplateSpecializationTypeBits.NumArgs</Size>
                <ValuePointer>(clang::TemplateArgument*)(this + 1)</ValuePointer>
            </ArrayItems>
        </Expand>
    </Type>

    <Type Name="clang::DeducedType">
        <Expand>
            <ExpandedItem>*(clang::Type*)this,nd</ExpandedItem>
            <Item Name="isDeduced">! is_canonical() || TypeBits.Dependent</Item>
        </Expand>
    </Type>

    <Type Name="clang::DeducedTemplateSpecializationType">
        <DisplayString Condition="! is_canonical() || TypeBits.Dependent">{CanonicalType,view(cpp)}</DisplayString>
        <DisplayString IncludeView="cpp">{Template,view(cpp)}</DisplayString>
        <DisplayString>{Template}</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::DeducedType*)this,nd</ExpandedItem>
            <Item Name="Template">Template</Item>
            <Item Name="Deduced" Condition="! is_canonical() || TypeBits.Dependent">CanonicalType,view(cpp)</Item>
            <Item Name="Template">Template</Item>
        </Expand>
    </Type>

    <Type Name="clang::ArrayType">
        <Expand>
            <ExpandedItem>*(clang::Type*)this,nd</ExpandedItem>
            <Item Name="ElementType">ElementType</Item>
        </Expand>
    </Type>
    <Type Name="clang::ConstantArrayType">
        <DisplayString IncludeView="left">{ElementType,view(cpp)}</DisplayString>
        <DisplayString IncludeView="right">[{Size}]</DisplayString>
        <DisplayString>{ElementType,view(cpp)}[{Size}]</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::ArrayType*)this,nd</ExpandedItem>
            <Item Name="Size">Size</Item>
        </Expand>
    </Type>
    <Type Name="clang::IncompleteArrayType">
        <DisplayString IncludeView="left">{ElementType,view(cpp)}</DisplayString>
        <DisplayString IncludeView="right">[]</DisplayString>
        <DisplayString>{ElementType,view(cpp)}[]</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::ArrayType*)this,nd</ExpandedItem>
        </Expand>
    </Type>
    <Type Name="clang::VariableArrayType">
        <DisplayString IncludeView="left">{ElementType,view(cpp)}</DisplayString>
        <DisplayString IncludeView="right">[*]</DisplayString>
        <DisplayString>{ElementType,view(cpp)}[*]</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::ArrayType*)this,nd</ExpandedItem>
            <Item Name="[Size Expression]">(clang::Expr*)SizeExpr</Item>
        </Expand>
    </Type>
    <Type Name="clang::TypedefType">
        <DisplayString IncludeView="cpp">{Decl,view(name)na}</DisplayString>
        <DisplayString>{Decl,view(name)na}</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::Type*)this,nd</ExpandedItem>
            <Item Name="Decl">Decl</Item>
        </Expand>
    </Type>
    <Type Name="clang::PointerType">
        <DisplayString>{PointeeType, view(cpp)} *</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::Type*)this,nd</ExpandedItem>
            <Item Name="PointeeType">PointeeType</Item>
        </Expand>
    </Type>
    <Type Name="clang::ParenType">
        <DisplayString>{Inner, view(cpp)}</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::Type*)this,nd</ExpandedItem>
            <Item Name="Inner">Inner</Item>
        </Expand>
    </Type>
    <Type Name="clang::BitIntType">
        <DisplayString Condition="!IsUnsigned">signed _BitInt({NumBits})</DisplayString>
        <DisplayString Condition="!IsUnsigned">unsigned _BitInt({NumBits})(</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::Type*)this,nd</ExpandedItem>
            <Item Name="NumBits">NumBits</Item>
        </Expand>
    </Type>
    <!-- We visualize all inner types for clang reference types. So a rvalue reference to an lvalue reference
       to an int  would visual as int &amp; &amp;&amp; This is a little different than GetPointeeType(),
       but more clearly displays the data structure and seems natural -->
    <Type Name="clang::LValueReferenceType">
        <DisplayString>{((clang::ReferenceType *)this)-&gt;PointeeType,view(cpp)} &amp;</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::Type*)this,nd</ExpandedItem>
            <Item Name="PointeeType">PointeeType</Item>
        </Expand>
    </Type>
    <Type Name="clang::RValueReferenceType">
        <DisplayString>{((clang::ReferenceType *)this)-&gt;PointeeType,view(cpp)} &amp;&amp;</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::Type*)this,nd</ExpandedItem>
            <Item Name="PointeeType">PointeeType</Item>
        </Expand>
    </Type>
    <Type Name="clang::AttributedType">
        <DisplayString>{ModifiedType} Attribute={(clang::AttributedType::Kind)AttributedTypeBits.AttrKind}</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::Type*)this,nd</ExpandedItem>
        </Expand>
    </Type>

    <Type Name="clang::TagType">
        <DisplayString IncludeView="cpp">{decl,view(name)na}</DisplayString>
        <DisplayString>{decl,view(name)na}</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::Type*)this,nd</ExpandedItem>
            <Item Name="Decl">decl</Item>
        </Expand>
    </Type>
    <Type Name="clang::RecordType">
        <DisplayString IncludeView="cpp">{(TagType*)this,view(cpp)nand}</DisplayString>
        <DisplayString>{(clang::TagType*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::TagType*)this,nd</ExpandedItem>
        </Expand>
    </Type>
    <!--
    <Type Name="clang::SubstTemplateTypeParmType">
        <DisplayString>{{{Replaced,view(cpp)} &lt;= {CanonicalType,view(cpp)}}}</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::Type *)this, view(cmn)</ExpandedItem>
            <Item Name="Replaced">Replaced</Item>
        </Expand>
    </Type>
    -->
    <Type Name="clang::SubstTemplateTypeParmType">
        <Intrinsic Category="Data" Name="get_replacement_type"
            Expression="SubstTemplateTypeParmTypeBits.HasNonCanonicalUnderlyingType ?
                (QualType*)(this + 1) : CanonicalType"/>
        <DisplayString>{{{CanonicalType,view(cpp)}}}</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::Type*)this,nd</ExpandedItem>
            <Item Name="AssociatedDecl">AssociatedDecl</Item>
            <Item Name="ReplacementType">get_replacement_type()</Item>
        </Expand>
    </Type>

    <!-- We only show the first 5 parameter types in the display string (can't figure out how to loop in DisplayString)
       but the expansion has all parameters -->
    <Type Name="clang::FunctionProtoType">
        <DisplayString IncludeView="left" Condition="FunctionTypeBits.HasTrailingReturn"></DisplayString>
        <DisplayString IncludeView="left">{ResultType,view(cpp)}</DisplayString>
        <DisplayString IncludeView="parm0" Condition="FunctionTypeBits.NumParams==0"></DisplayString>
        <DisplayString IncludeView="parm0">{*(clang::QualType *)(this+1),view(cpp)}{*this,view(parm1)}</DisplayString>
        <DisplayString IncludeView="parm1" Condition="FunctionTypeBits.NumParams==1"></DisplayString>
        <DisplayString IncludeView="parm1">, {*((clang::QualType *)(this+1)+1),view(cpp)}{*this,view(parm2)}</DisplayString>
        <DisplayString IncludeView="parm2" Condition="FunctionTypeBits.NumParams==2"></DisplayString>
        <DisplayString IncludeView="parm2">, {*((clang::QualType *)(this+1)+2),view(cpp)}{*this,view(parm3)}</DisplayString>
        <DisplayString IncludeView="parm3" Condition="FunctionTypeBits.NumParams==3"></DisplayString>
        <DisplayString IncludeView="parm3">, {*((clang::QualType *)(this+1)+3),view(cpp)}{*this,view(parm4)}</DisplayString>
        <DisplayString IncludeView="parm4" Condition="FunctionTypeBits.NumParams==4"></DisplayString>
        <DisplayString IncludeView="parm4">, {*((clang::QualType *)(this+1)+4),view(cpp)}{*this,view(parm5)}</DisplayString>
        <DisplayString IncludeView="parm5" Condition="FunctionTypeBits.NumParams==5"></DisplayString>
        <DisplayString IncludeView="parm5">, /* expand for more params */</DisplayString>
        <DisplayString IncludeView="right" Condition="FunctionTypeBits.HasTrailingReturn">({*this,view(parm0)}) -&gt; {ResultType,view(cpp)}</DisplayString>
        <DisplayString IncludeView="right">({*this,view(parm0)})</DisplayString>
        <DisplayString>{this,view(left)na}{this,view(right)na}</DisplayString>

        <Expand>
            <ExpandedItem>*(clang::Type*)this,nd</ExpandedItem>
            <Item Name="[return type]">ResultType</Item>
            <Synthetic Name="[parameter types]">
                <DisplayString>size = {FunctionTypeBits.NumParams}</DisplayString>
                <Expand>
                    <ArrayItems>
                        <Size>FunctionTypeBits.NumParams</Size>
                        <ValuePointer>(clang::QualType*)(this + 1)</ValuePointer>
                    </ArrayItems>
                </Expand>
            </Synthetic>
        </Expand>
    </Type>

    <Type Name="clang::AdjustedType">
        <DisplayString>{OriginalTy} adjusted to {AdjustedTy}</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::Type*)this,nd</ExpandedItem>
            <Item Name="Original">OriginalTy</Item>
            <Item Name="Adjusted">AdjustedTy</Item>
        </Expand>
    </Type>
    <Type Name="clang::DecayedType">
        <DisplayString IncludeView="left">{OriginalTy,view(left)}</DisplayString>
        <DisplayString IncludeView="right">{OriginalTy,view(right)}</DisplayString>
        <DisplayString>{OriginalTy}</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::AdjustedType*)this,nd</ExpandedItem>
        </Expand>
    </Type>
    <Type Name="clang::ElaboratedType">
        <DisplayString IncludeView="left">{NamedType,view(left)}</DisplayString>
        <DisplayString IncludeView="right">{NamedType,view(right)}</DisplayString>
        <DisplayString>{NamedType}</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::Type*)this,nd</ExpandedItem>
            <Item Name="Keyword">(clang::ElaboratedTypeKeyword)TypeWithKeywordBits.Keyword</Item>
            <Item Name="[nested name specifier]">NNS</Item>
            <Item Name="[underlying type]">NamedType,view(cmn)</Item>
        </Expand>
    </Type>
    <Type Name="clang::TemplateTypeParmType">
        <DisplayString IncludeView="cpp" Condition="! is_canonical()">{TTPDecl,view(name)na}</DisplayString>
        <!--<DisplayString Condition="! is_canonical()">Non-canonical: {TTPDecl,view(name)na}</DisplayString>-->
        <DisplayString Condition="! is_canonical()">{TTPDecl,view(name)na}</DisplayString>

        <!--<DisplayString>Canonical: {CanTTPTInfo}</DisplayString>-->
        <DisplayString>{CanTTPTInfo}</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::Type*)this,nd</ExpandedItem>
        </Expand>
    </Type>
    <Type Name="clang::InjectedClassNameType">
        <DisplayString>{Decl,view(name)}</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::Type*)this,nd</ExpandedItem>
            <Item Name="Decl">Decl</Item>
            <Item Name="InjectedType">InjectedType</Item>
        </Expand>
    </Type>
    <Type Name="clang::DependentNameType">
        <DisplayString>{NNS}{Name,view(cpp)na}</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::Type*)this,nd</ExpandedItem>
            <Item Name="Name">Name</Item>
            <Item Name="[nested name specifier]">NNS</Item>
        </Expand>
    </Type>

    <Type Name="clang::PackExpansionType">
        <DisplayString>{Pattern}</DisplayString>
        <Expand>
            <ExpandedItem>*(clang::Type*)this,nd</ExpandedItem>
            <Item Name="Pattern">Pattern</Item>
            <Item Name="Expansions">
                PackExpansionTypeBits.NumExpansions ? PackExpansionTypeBits.NumExpansions - 1 : 0
            </Item>
        </Expand>
    </Type>

    <Type Name="clang::LocInfoType">
        <DisplayString IncludeView="cpp">{DeclInfo,view(cpp)na}</DisplayString>
        <DisplayString>{DeclInfo,na}</DisplayString>
        <Expand>
            <Item Name="DeclInfo">DeclInfo</Item>
            <ExpandedItem>*(clang::Type *)this, view(cmn)</ExpandedItem>
        </Expand>
    </Type>

    <!-- ================================================================================================ -->

    <Type Name="clang::Redeclarable&lt;*&gt;">
        <Intrinsic Category="Data" Name="get_value" Expression="*(uintptr_t*)&amp;RedeclLink.Link" />
        <Intrinsic Category="Data" Name="get_int" Expression="get_value() &amp; 7ull" />
        <Intrinsic Category="Data" Name="get_void_ptr" Expression="(void*)(get_value() &amp; ~7ull)" />
        <!--
        get_int() & 3 == 0: NotKnownLatest, stores Decl*
        get_int() & 5 == 1: KnownLatest, stores Decl*
        get_int() & 3 == 2: NotKnownLatest, stores const void* (pointer to ASTContext)
        get_int() & 5 == 5: KnownLatest, stores LazyData*
        -->
        <Intrinsic Category="Data" Name="get_previous" Expression="($T1*)(
            (get_int() &amp; 3) == 2 ? First : ((get_int() &amp; 5) != 5 ? get_void_ptr() :
                ((DeclLink::KnownLatest::LazyData*)get_void_ptr())-&gt;LastValue))" />
        <Intrinsic Category="Data" Name="get_first" Expression="First" />
        <Intrinsic Category="Data" Name="get_latest" Expression="get_first()-&gt;get_previous()" />
        <Intrinsic Category="Data" Name="is_first" Expression="(get_int() &amp; 3) != 0" />

        <!--
        <Expand>
            <Synthetic Name="[redeclarations]" Condition="get_first() != get_latest()">
                <DisplayString></DisplayString>
                <Expand>
                    <LinkedListItems>
                        <HeadPointer>get_first()</HeadPointer>
                        <NextPointer>get_previous()</NextPointer>
                        <ValueNode>($T1*)this</ValueNode>
                    </LinkedListItems>
                </Expand>
            </Synthetic>
        </Expand>
        -->
        <Expand>
            <Synthetic Name="[redeclarations]" Condition="get_first() != get_latest()">
                <DisplayString></DisplayString>
                <Expand>
                    <Item Name="[first]">get_first()</Item>
                    <LinkedListItems Condition="get_latest()-&gt;get_previous() != get_first()">
                        <HeadPointer>get_latest()-&gt;get_previous()</HeadPointer>
                        <NextPointer>get_previous()-&gt;is_first() ? nullptr : get_previous()</NextPointer>
                        <ValueNode>($T1*)this</ValueNode>
                    </LinkedListItems>
                    <Item Name="[latest]">get_latest()</Item>
                </Expand>
            </Synthetic>
        </Expand>
    </Type>

    <!-- ================================================================================================ -->

    <Type Name="clang::Decl">
        <Intrinsic Category="Data" Name="get_kind" Expression="(clang::Decl::Kind)DeclKind" />
        <Intrinsic Category="Data" Name="get_semantic_dc" Expression="(DeclContext*)(DeclCtx.is_null() ? nullptr :
            (DeclCtx.get_int() == 0 ? DeclCtx.get_ptr() : ((Decl::MultipleDC*)DeclCtx.get_ptr())-&gt;SemanticDC))" />
        <Intrinsic Category="Data" Name="get_lexical_dc" Expression="(DeclContext*)(DeclCtx.get_int() != 1 ? nullptr :
            ((Decl::MultipleDC*)DeclCtx.get_ptr())-&gt;LexicalDC)" />
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::AccessSpec">(AccessSpecDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::Block">(BlockDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::Captured">(CapturedDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ClassScopeFunctionSpecialization">(ClassScopeFunctionSpecializationDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::Empty">(EmptyDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::Export">(ExportDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ExternCContext">(ExternCContextDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::FileScopeAsm">(FileScopeAsmDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::Friend">(FriendDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::FriendTemplate">(FriendTemplateDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ImplicitConceptSpecialization">(ImplicitConceptSpecializationDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::Import">(ImportDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::LifetimeExtendedTemporary">(LifetimeExtendedTemporaryDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::LinkageSpec">(LinkageSpecDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::Using">(UsingDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::UsingEnum">(UsingEnumDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::HLSLBuffer">(HLSLBufferDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::Label">(LabelDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::Namespace">(NamespaceDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::NamespaceAlias">(NamespaceAliasDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ObjCCompatibleAlias">(ObjCCompatibleAliasDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ObjCCategory">(ObjCCategoryDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ObjCCategoryImpl">(ObjCCategoryImplDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ObjCImplementation">(ObjCImplementationDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ObjCInterface">(ObjCInterfaceDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ObjCProtocol">(ObjCProtocolDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ObjCMethod">(ObjCMethodDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ObjCProperty">(ObjCPropertyDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::BuiltinTemplate">(BuiltinTemplateDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::Concept">(ConceptDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ClassTemplate">(ClassTemplateDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::FunctionTemplate">(FunctionTemplateDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::TypeAliasTemplate">(TypeAliasTemplateDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::VarTemplate">(VarTemplateDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::TemplateTemplateParm">(TemplateTemplateParmDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::Enum">(EnumDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::Record">(RecordDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::CXXRecord">(CXXRecordDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ClassTemplateSpecialization">(ClassTemplateSpecializationDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ClassTemplatePartialSpecialization">(ClassTemplatePartialSpecializationDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::TemplateTypeParm">(TemplateTypeParmDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ObjCTypeParam">(ObjCTypeParamDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::TypeAlias">(TypeAliasDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::Typedef">(TypedefDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::UnresolvedUsingTypename">(UnresolvedUsingTypenameDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::UnresolvedUsingIfExists">(UnresolvedUsingIfExistsDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::UsingDirective">(UsingDirectiveDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::UsingPack">(UsingPackDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::UsingShadow">(UsingShadowDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ConstructorUsingShadow">(ConstructorUsingShadowDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::Binding">(BindingDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::Field">(FieldDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ObjCAtDefsField">(ObjCAtDefsFieldDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ObjCIvar">(ObjCIvarDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::Function">(FunctionDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::CXXDeductionGuide">(CXXDeductionGuideDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::CXXMethod">(CXXMethodDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::CXXConstructor">(CXXConstructorDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::CXXConversion">(CXXConversionDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::CXXDestructor">(CXXDestructorDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::MSProperty">(MSPropertyDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::NonTypeTemplateParm">(NonTypeTemplateParmDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::Var">(VarDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::Decomposition">(DecompositionDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ImplicitParam">(ImplicitParamDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::OMPCapturedExpr">(OMPCapturedExprDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ParmVar">(ParmVarDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::VarTemplateSpecialization">(VarTemplateSpecializationDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::VarTemplatePartialSpecialization">(VarTemplatePartialSpecializationDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::EnumConstant">(EnumConstantDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::IndirectField">(IndirectFieldDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::MSGuid">(MSGuidDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::OMPDeclareMapper">(OMPDeclareMapperDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::OMPDeclareReduction">(OMPDeclareReductionDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::TemplateParamObject">(TemplateParamObjectDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::UnnamedGlobalConstant">(UnnamedGlobalConstantDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::UnresolvedUsingValue">(UnresolvedUsingValueDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::OMPAllocate">(OMPAllocateDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::OMPRequires">(OMPRequiresDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::OMPThreadPrivate">(OMPThreadPrivateDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::ObjCPropertyImpl">(ObjCPropertyImplDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::PragmaComment">(PragmaCommentDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::PragmaDetectMismatch">(PragmaDetectMismatchDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::RequiresExprBody">(RequiresExprBodyDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::StaticAssert">(StaticAssertDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::TopLevelStmt">(TopLevelStmtDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclKind == Decl::TranslationUnit">(TranslationUnitDecl*)this</MostDerivedType>

        <DisplayString Condition="Implicit">(implicit) {get_kind(),en}</DisplayString>
        <DisplayString>{get_kind(),en}</DisplayString>

        <Expand>
            <Item Name="Kind">get_kind(),en</Item>
            <Item Name="ID">(uintptr_t)this,x</Item>
            <Synthetic Name="Access">
                <DisplayString Condition="Access == clang::AccessSpecifier::AS_public">public</DisplayString>
                <DisplayString Condition="Access == clang::AccessSpecifier::AS_protected">protected</DisplayString>
                <DisplayString Condition="Access == clang::AccessSpecifier::AS_private">private</DisplayString>
                <DisplayString Condition="Access == clang::AccessSpecifier::AS_none">none</DisplayString>
                <DisplayString>invalid</DisplayString>
            </Synthetic>
            <Synthetic Name="Context" Condition="! DeclCtx.is_null()">
                <DisplayString Condition="DeclCtx.get_int() == 0">Semantic = {(Decl::Kind)(get_semantic_dc()-&gt;DeclContextBits.DeclKind),en}</DisplayString>
                <DisplayString Condition="DeclCtx.get_int() == 1">Semantic = {(Decl::Kind)(get_semantic_dc()-&gt;DeclContextBits.DeclKind),en}, Lexical = {(Decl::Kind)(get_lexical_dc()-&gt;DeclContextBits.DeclKind),en}</DisplayString>
                <Expand>
                    <Item Name="Semantic">get_semantic_dc()</Item>
                    <Item Name="Lexical" Condition="DeclCtx.get_int() == 1">get_lexical_dc()</Item>
                </Expand>
            </Synthetic>
        </Expand>
        <!--
        -->
    </Type>

    <Type Name="clang::DeclContext">
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::Function">(FunctionDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::CXXDeductionGuide">(CXXDeductionGuideDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::CXXMethod">(CXXMethodDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::CXXConstructor">(CXXConstructorDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::CXXConversion">(CXXConversionDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::CXXDestructor">(CXXDestructorDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::Enum">(EnumDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::Record">(RecordDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::CXXRecord">(CXXRecordDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::ClassTemplateSpecialization">(ClassTemplateSpecializationDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::ClassTemplatePartialSpecialization">(ClassTemplatePartialSpecializationDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::Block">(BlockDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::Captured">(CapturedDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::TranslationUnit">(TranslationUnitDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::Namespace">(NamespaceDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::LinkageSpec">(LinkageSpecDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::ExternCContext">(ExternCContextDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::Export">(ExportDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::RequiresExprBody">(RequiresExprBodyDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::ObjCCategory">(ObjCCategoryDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::ObjCCategoryImpl">(ObjCCategoryImplDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::ObjCImplementation">(ObjCImplementationDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::ObjCInterface">(ObjCInterfaceDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::ObjCProtocol">(ObjCProtocolDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::HLSLBuffer">(HLSLBufferDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::OMPDeclareMapper">(OMPDeclareMapperDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::OMPDeclareReduction">(OMPDeclareReductionDecl*)this</MostDerivedType>
        <MostDerivedType Condition="(Decl::Kind)DeclContextBits.DeclKind == Decl::ObjCMethod">(ObjCMethodDecl*)this</MostDerivedType>

        <Expand>
            <Synthetic Name="[members]" Condition="FirstDecl">
                <DisplayString></DisplayString>
                <Expand>
                    <LinkedListItems>
                        <HeadPointer>FirstDecl</HeadPointer>
                        <NextPointer>NextInContextAndBits.get_ptr()</NextPointer>
                        <ValueNode>*this</ValueNode>
                    </LinkedListItems>
                </Expand>
            </Synthetic>
        </Expand>
    </Type>

    <!-- ================================================================================================ -->

    <Type Name="clang::NamedDecl">
        <DisplayString IncludeView="name">{Name}</DisplayString>
        <DisplayString>{(Decl*)this,nand} {Name}</DisplayString>
        <Expand>
            <ExpandedItem>*(Decl*)this,nd</ExpandedItem>
            <Item Name="Name">Name</Item>
        </Expand>
    </Type>

    <Type Name="clang::ValueDecl">
        <DisplayString IncludeView="name">{DeclType,view(left)} {Name} {DeclType,view(right)}</DisplayString>
        <DisplayString>{(Decl*)this,nand} {DeclType,view(left)} {Name} {DeclType,view(right)}</DisplayString>
        <Expand>
            <ExpandedItem>*(NamedDecl*)this,nd</ExpandedItem>
            <Item Name="Type">DeclType</Item>
        </Expand>
    </Type>

    <Type Name="clang::TypeDecl">
        <DisplayString IncludeView="name">{Name}</DisplayString>
        <DisplayString>{(NamedDecl*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(NamedDecl*)this,nd</ExpandedItem>
            <Item Name="Type">TypeForDecl</Item>
        </Expand>
    </Type>

    <Type Name="clang::DeclaratorDecl">
        <Intrinsic Category="Data" Name="get_type_as_written"
            Expression="DeclInfo.is_null() ? nullptr : (TypeSourceInfo*)(DeclInfo.get_int() == 0 ?
                DeclInfo.get_ptr() : ((clang::DeclaratorDecl::ExtInfo*)DeclInfo.get_ptr())-&gt;TInfo)"/>

        <DisplayString>{(ValueDecl*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(NamedDecl*)this,nd</ExpandedItem>
            <Synthetic Name="Type">
                <DisplayString>{DeclType}</DisplayString>
                <Expand>
                    <Item Name="Type">DeclType</Item>
                    <Item Name="TypeAsWritten">get_type_as_written(),na</Item>
                </Expand>
            </Synthetic>
        </Expand>
    </Type>

    <Type Name="clang::TagDecl">
        <DisplayString Condition="(TagTypeKind)TagDeclBits.TagDeclKind == TagTypeKind::TTK_Struct">{(Decl*)this,nand} struct {Name}</DisplayString>
        <DisplayString Condition="(TagTypeKind)TagDeclBits.TagDeclKind == TagTypeKind::TTK_Class">{(Decl*)this,nand} class {Name}</DisplayString>
        <DisplayString Condition="(TagTypeKind)TagDeclBits.TagDeclKind == TagTypeKind::TTK_Union">{(Decl*)this,nand} union {Name}</DisplayString>
        <DisplayString Condition="(TagTypeKind)TagDeclBits.TagDeclKind == TagTypeKind::TTK_Enum">{(Decl*)this,nand} enum {Name}</DisplayString>
        <DisplayString Condition="(TagTypeKind)TagDeclBits.TagDeclKind == TagTypeKind::TTK_Interface">{(Decl*)this,nand} __interface {Name}</DisplayString>
        <DisplayString>{(NamedDecl*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(NamedDecl*)this,nd</ExpandedItem>
            <Synthetic Name="TagKind">
                <DisplayString Condition="(TagTypeKind)TagDeclBits.TagDeclKind == TagTypeKind::TTK_Struct">struct</DisplayString>
                <DisplayString Condition="(TagTypeKind)TagDeclBits.TagDeclKind == TagTypeKind::TTK_Class">class</DisplayString>
                <DisplayString Condition="(TagTypeKind)TagDeclBits.TagDeclKind == TagTypeKind::TTK_Union">union</DisplayString>
                <DisplayString Condition="(TagTypeKind)TagDeclBits.TagDeclKind == TagTypeKind::TTK_Enum">enum</DisplayString>
                <DisplayString Condition="(TagTypeKind)TagDeclBits.TagDeclKind == TagTypeKind::TTK_Interface">__interface</DisplayString>
                <DisplayString>invalid</DisplayString>
            </Synthetic>
            <ExpandedItem>*(redeclarable_base*)this,nd</ExpandedItem>
            <ExpandedItem>*(DeclContext*)this,nd</ExpandedItem>
        </Expand>
    </Type>

    <Type Name="clang::TypedefNameDecl">
        <!-- types with modified width (i.e. those using ModedTInfo) not yet supported -->
        <Intrinsic Category="Data" Name="get_int" Expression="(uintptr_t)MaybeModedTInfo.get_void_ptr() &amp; 7ull"/>
        <Intrinsic Category="Data" Name="get_ptr" Expression="(uintptr_t)MaybeModedTInfo.get_void_ptr() &amp; ~7ull"/>
        <Intrinsic Category="Data" Name="get_type_as_written"
            Expression="MaybeModedTInfo.is_null() ? nullptr :
                (get_int() ? nullptr : (TypeSourceInfo*)get_ptr())"/>

        <DisplayString IncludeView="name">{Name}</DisplayString>
        <DisplayString>{(NamedDecl*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(NamedDecl*)this,nd</ExpandedItem>
            <Item Name="Type">get_type_as_written()</Item>
            <ExpandedItem>*(redeclarable_base*)this,nd</ExpandedItem>
        </Expand>
    </Type>

    <Type Name="clang::TypedefDecl">
        <DisplayString>{(TypedefNameDecl*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(TypedefNameDecl*)this,nd</ExpandedItem>
        </Expand>
    </Type>

    <Type Name="clang::TypeAliasDecl">
        <DisplayString>{(TypedefNameDecl*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(NamedDecl*)this,nd</ExpandedItem>
            <Item Name="Type">get_type_as_written()</Item>
            <Item Name="DescribedTemplate" Condition="Template">Template</Item>
            <ExpandedItem>*(redeclarable_base*)this,nd</ExpandedItem>
        </Expand>
    </Type>

    <Type Name="clang::TemplateDecl">
        <DisplayString>{(NamedDecl*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(NamedDecl*)this,nd</ExpandedItem>
            <Item Name="TemplateParams">TemplateParams,na</Item>
            <Item Name="TemplatedDecl">TemplatedDecl,na</Item>
        </Expand>
    </Type>

    <!-- ================================================================================================ -->

    <Type Name="clang::NamespaceDecl">
        <DisplayString>{(NamedDecl*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(NamedDecl*)this,nd</ExpandedItem>
            <ExpandedItem>*(redeclarable_base*)this,nd</ExpandedItem>
            <ExpandedItem>*(DeclContext*)this,nd</ExpandedItem>
        </Expand>
    </Type>

    <Type Name="clang::TranslationUnitDecl">
        <DisplayString>{(Decl*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(Decl*)this,nd</ExpandedItem>
            <ExpandedItem>*(redeclarable_base*)this,nd</ExpandedItem>
            <ExpandedItem>*(DeclContext*)this,nd</ExpandedItem>
        </Expand>
    </Type>

    <Type Name="clang::LinkageSpecDecl">
        <DisplayString>{(Decl*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(Decl*)this,nd</ExpandedItem>
            <ExpandedItem>*(DeclContext*)this,nd</ExpandedItem>
        </Expand>
    </Type>

    <Type Name="clang::FunctionDecl" Inheritable="false">
        <AlternativeType Name="clang::CXXMethodDecl" Inheritable="false" />
        <AlternativeType Name="clang::CXXConstructorDecl" Inheritable="false" />
        <AlternativeType Name="clang::CXXConversionDecl" Inheritable="false" />
        <AlternativeType Name="clang::CXXDestructorDecl" Inheritable="false" />
        <AlternativeType Name="clang::CXXDeductionGuide" Inheritable="false" />

        <DisplayString>{(DeclaratorDecl*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(DeclaratorDecl*)this,nd</ExpandedItem>

            <Item Name="DescribedTemplate" Condition="! TemplateOrSpecialization.is_null() &amp;&amp;
                TemplateOrSpecialization.get_int() == 0 &amp;&amp;
                    ((NamedDecl*)TemplateOrSpecialization.get_ptr())-&gt;get_kind() == Decl::FunctionTemplate">
                        (FunctionTemplateDecl*)TemplateOrSpecialization.get_ptr()
            </Item>
            <Item Name="InstantiatedFrom" Condition="! TemplateOrSpecialization.is_null() &amp;&amp;
                TemplateOrSpecialization.get_int() == 0 &amp;&amp;
                    ((NamedDecl*)TemplateOrSpecialization.get_ptr())-&gt;get_kind() == Decl::Function">
                        (FunctionDecl*)TemplateOrSpecialization.get_ptr()
            </Item>

            <Item Name="MemberSpecialization" Condition="! TemplateOrSpecialization.is_null() &amp;&amp; TemplateOrSpecialization.get_int() == 1">
                (MemberSpecializationInfo*)TemplateOrSpecialization.get_ptr()
            </Item>

            <Item Name="TemplateSpecialization" Condition="! TemplateOrSpecialization.is_null() &amp;&amp; TemplateOrSpecialization.get_int() == 2">
                (FunctionTemplateSpecializationInfo*)TemplateOrSpecialization.get_ptr()
            </Item>

            <Synthetic Name="[parameters]">
                <DisplayString Condition="ParamInfo &amp;&amp; DeclType.is(Type::FunctionProto)">size = {DeclType.get_type_ptr()-&gt;FunctionTypeBits.NumParams}</DisplayString>
                <DisplayString>size = 0</DisplayString>
                <Expand>
                    <ArrayItems Condition="ParamInfo &amp;&amp; DeclType.is(Type::FunctionProto)">
                        <Size>DeclType.get_type_ptr()-&gt;FunctionTypeBits.NumParams</Size>
                        <ValuePointer>ParamInfo</ValuePointer>
                    </ArrayItems>
                </Expand>
            </Synthetic>

            <ExpandedItem>*(redeclarable_base*)this,nd</ExpandedItem>
            <ExpandedItem>*(DeclContext*)this,nd</ExpandedItem>
        </Expand>
    </Type>

    <!-- ================================================================================================ -->

    <Type Name="clang::ClassTemplateDecl::Common">
        <Expand>
            <ExpandedItem>*(RedeclarableTemplateDecl::CommonBase*)this,nd</ExpandedItem>
            <Item Name="InjectedClassNameType">InjectedClassNameType</Item>
            <Synthetic Name="[specializations]">
                <DisplayString Condition="Specializations.Vector.Size == 0">empty</DisplayString>
                <DisplayString Condition="Specializations.Vector.Size != 0">{(size_t)Specializations.Vector.Size} elements</DisplayString>
                <Expand>
                    <ArrayItems>
                        <Size>(size_t)Specializations.Vector.Size</Size>
                        <ValuePointer>(ClassTemplateSpecializationDecl**)Specializations.Vector.BeginX</ValuePointer>
                    </ArrayItems>
                </Expand>
            </Synthetic>
            <Synthetic Name="[partial specializations]">
                <DisplayString Condition="PartialSpecializations.Vector.Size == 0">empty</DisplayString>
                <DisplayString Condition="PartialSpecializations.Vector.Size != 0">{(size_t)PartialSpecializations.Vector.Size} elements</DisplayString>
                <Expand>
                    <ArrayItems>
                        <Size>(size_t)PartialSpecializations.Vector.Size</Size>
                        <ValuePointer>(ClassTemplatePartialSpecializationDecl**)PartialSpecializations.Vector.BeginX</ValuePointer>
                    </ArrayItems>
                </Expand>
            </Synthetic>
        </Expand>
    </Type>

    <Type Name="clang::VarTemplateDecl::Common">
        <Expand>
            <ExpandedItem>*(RedeclarableTemplateDecl::CommonBase*)this,nd</ExpandedItem>
            <Synthetic Name="[specializations]">
                <DisplayString Condition="Specializations.Vector.Size == 0">empty</DisplayString>
                <DisplayString Condition="Specializations.Vector.Size != 0">{(size_t)Specializations.Vector.Size} elements</DisplayString>
                <Expand>
                    <ArrayItems>
                        <Size>(size_t)Specializations.Vector.Size</Size>
                        <ValuePointer>(VarTemplateSpecializationDecl**)Specializations.Vector.BeginX</ValuePointer>
                    </ArrayItems>
                </Expand>
            </Synthetic>
            <Synthetic Name="[partial specializations]">
                <DisplayString Condition="PartialSpecializations.Vector.Size == 0">empty</DisplayString>
                <DisplayString Condition="PartialSpecializations.Vector.Size != 0">{(size_t)PartialSpecializations.Vector.Size} elements</DisplayString>
                <Expand>
                    <ArrayItems>
                        <Size>(size_t)PartialSpecializations.Vector.Size</Size>
                        <ValuePointer>(VarTemplatePartialSpecializationDecl**)PartialSpecializations.Vector.BeginX</ValuePointer>
                    </ArrayItems>
                </Expand>
            </Synthetic>
        </Expand>
    </Type>

    <Type Name="clang::FunctionTemplateDecl::Common">
        <Expand>
            <ExpandedItem>*(RedeclarableTemplateDecl::CommonBase*)this,nd</ExpandedItem>
            <!--<Item Name="Specializations">Specializations</Item>-->
            <Synthetic Name="[specializations]">
                <DisplayString Condition="Specializations.Vector.Size == 0">empty</DisplayString>
                <DisplayString Condition="Specializations.Vector.Size != 0">{(size_t)Specializations.Vector.Size} elements</DisplayString>
                <Expand>
                    <ArrayItems>
                        <Size>(size_t)Specializations.Vector.Size</Size>
                        <ValuePointer>(FunctionTemplateSpecializationInfo**)Specializations.Vector.BeginX</ValuePointer>
                    </ArrayItems>
                </Expand>
            </Synthetic>
        </Expand>
    </Type>

    <Type Name="clang::TypeAliasTemplateDecl::Common">
        <Expand>
            <ExpandedItem>*(RedeclarableTemplateDecl::CommonBase*)this,nd</ExpandedItem>
        </Expand>
    </Type>

    <Type Name="clang::RedeclarableTemplateDecl::CommonBase">
        <Expand>
            <Item Name="IsMemberSpecialization">InstantiatedFromMember.get_int()</Item>
            <Item Name="InstantiatedFromMember" Condition="! InstantiatedFromMember.is_null()">InstantiatedFromMember.get_ptr()</Item>
            <Item Name="LazySpecializations" Condition="LazySpecializations != nullptr">LazySpecializations</Item>
            <Item Name="InjectedArgs" Condition="InjectedArgs != nullptr">InjectedArgs</Item>
        </Expand>
    </Type>

    <!-- ================================================================================================ -->

    <Type Name="clang::FieldDecl">
        <DisplayString>{(DeclaratorDecl*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(DeclaratorDecl*)this,nd</ExpandedItem>
        </Expand>
    </Type>

    <!-- ================================================================================================ -->

    <Type Name="clang::FriendDecl">
        <DisplayString>{(Decl*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(Decl*)this,nd</ExpandedItem>
            <Synthetic Name="TemplateParams" Condition="NumTPLists">
                <Expand>
                    <ArrayItems>
                        <Size>NumTPLists</Size>
                        <ValuePointer>(TemplateParameterList**)(this + 1)</ValuePointer>
                    </ArrayItems>
                </Expand>
            </Synthetic>

            <Item Name="FriendDecl" Condition="! Friend.is_null() &amp;&amp; Friend.get_int() == 0">(NamedDecl*)Friend.get_ptr()</Item>
            <Item Name="FriendType" Condition="! Friend.is_null() &amp;&amp; Friend.get_int() == 1">(TypeSourceInfo*)Friend.get_ptr()</Item>
            <Item Name="Unsupported">(bool)UnsupportedFriend</Item>
        </Expand>
    </Type>

    <!-- FriendTemplateDecl is not currently used
    <Type Name="clang::FriendTemplateDecl">
        <DisplayString>{(Decl*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(Decl*)this,nd</ExpandedItem>

            <Item Name="FriendDecl" Condition="! Friend.is_null() &amp;&amp; Friend.get_int() == 0">(NamedDecl*)Friend.get_ptr()</Item>
            <Item Name="FriendType" Condition="! Friend.is_null() &amp;&amp; Friend.get_int() == 1">(TypeSourceInfo*)Friend.get_ptr()</Item>
        </Expand>
    </Type>
    -->

    <!-- ================================================================================================ -->

    <Type Name="clang::RedeclarableTemplateDecl">
        <Intrinsic Category="Data" Name="get_common_ptr" Expression="((RedeclarableTemplateDecl*)get_first())-&gt;Common"/>

        <DisplayString>{(TemplateDecl*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(TemplateDecl*)this,nd</ExpandedItem>

            <!--
            KRYSTIAN NOTE: this implements RedeclarableTemplateDecl::getCommonPtr without allocating/updating redeclarations.
            however, i think that using the CommonPtr stored in the first declaration should be good enough since it is propagated to
            all previous declarations upon access. as far as i know the only circumstance using the CommonPtr from the first
            declaration would not work is in an intermediate state during parsing... right?
            <CustomListItems Optional="true">
                <Variable Name="decl" InitialValue="this"/>
                <Variable Name="common" InitialValue="decl-&gt;Common"/>
                <Loop Condition="! common &amp;&amp; ! decl-&gt;is_first()">
                    <Exec>decl = (RedeclarableTemplateDecl*)(decl-&gt;get_previous())</Exec>
                    <Exec>common = decl ? decl-&gt;Common : nullptr</Exec>
                </Loop>
                <If Condition="common">
                    <Item Condition="get_kind() == Decl::ClassTemplate" Name="[common base]">(ClassTemplateDecl::Common*)common</Item>
                    <Item Condition="get_kind() == Decl::VarTemplate" Name="[common base]">(VarTemplateDecl::Common*)common</Item>
                    <Item Condition="get_kind() == Decl::FunctionTemplate" Name="[common base]">(FunctionTemplateDecl::Common*)common</Item>
                    <Item Condition="get_kind() == Decl::TypeAliasTemplate" Name="[common base]">(TypeAliasTemplateDecl::Common*)common</Item>
                </If>
            </CustomListItems>
            -->
            <ExpandedItem Condition="get_common_ptr() != nullptr &amp;&amp; get_kind() == Decl::ClassTemplate">
                *(ClassTemplateDecl::Common*)get_common_ptr()
            </ExpandedItem>
            <ExpandedItem Condition="get_common_ptr() != nullptr &amp;&amp; get_kind() == Decl::VarTemplate">
                *(VarTemplateDecl::Common*)get_common_ptr()
            </ExpandedItem>
            <ExpandedItem Condition="get_common_ptr() != nullptr &amp;&amp; get_kind() == Decl::FunctionTemplate">
                *(FunctionTemplateDecl::Common*)get_common_ptr()
            </ExpandedItem>
            <ExpandedItem Condition="get_common_ptr() != nullptr &amp;&amp; get_kind() == Decl::TypeAliasTemplate">
                *(TypeAliasTemplateDecl::Common*)get_common_ptr()
            </ExpandedItem>

            <ExpandedItem>*(redeclarable_base*)this,nd</ExpandedItem>
        </Expand>
    </Type>

    <!-- ================================================================================================ -->

    <Type Name="clang::TypeAliasTemplateDecl">
        <DisplayString>{(RedeclarableTemplateDecl*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(RedeclarableTemplateDecl*)this,nd</ExpandedItem>
        </Expand>
    </Type>

    <!-- ================================================================================================ -->

    <Type Name="clang::FunctionTemplateDecl">
        <DisplayString>{(RedeclarableTemplateDecl*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(RedeclarableTemplateDecl*)this,nd</ExpandedItem>
        </Expand>
    </Type>

    <Type Name="clang::FunctionTemplateSpecializationInfo">
        <Expand>
            <Item Name="SpecializationKind">clang::TemplateSpecializationKind(Template.get_int() + 1),en</Item>
            <Item Name="IsMemberSpecialization">Function.get_int()</Item>
            <Item Name="InstantiatedFromMember" Condition="Function.get_int()">
                *reinterpret_cast&lt;MemberSpecializationInfo**&gt;(this + 1)
            </Item>
            <Item Name="Function" Condition="! Function.is_null()">Function.get_ptr()</Item>
            <Item Name="Template" Condition="! Template.is_null()">Template.get_ptr()</Item>
            <Item Name="TemplateArguments">TemplateArguments</Item>
            <Item Name="TemplateArgumentsAsWritten">TemplateArgumentsAsWritten</Item>
            <Item Name="PointOfInstantiation">PointOfInstantiation</Item>
        </Expand>
    </Type>

    <Type Name="clang::ClassScopeFunctionSpecializationDecl">
        <Expand>
            <ExpandedItem>*(Decl*)this,nd</ExpandedItem>
            <Item Name="TemplateArgs">TemplateArgs,na</Item>
            <Item Name="Specialization">Specialization</Item>
        </Expand>
    </Type>

    <!-- ================================================================================================ -->

    <Type Name="clang::MemberSpecializationInfo">
        <Expand>
            <Item Name="SpecializationKind">clang::TemplateSpecializationKind(MemberAndTSK.get_int() + 1),en</Item>
            <Item Name="InstantiatedFrom" Condition="! MemberAndTSK.is_null()">
                MemberAndTSK.get_ptr()
            </Item>
            <Item Name="PointOfInstantiation">PointOfInstantiation</Item>
        </Expand>
    </Type>

    <!-- ================================================================================================ -->

    <Type Name="clang::ParmVarDecl">
        <DisplayString>{*(VarDecl*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(VarDecl*)this,nd</ExpandedItem>
            <Item Name="ParmVarDeclBits">ParmVarDeclBits</Item>
        </Expand>
    </Type>

    <Type Name="clang::VarDecl">
        <AlternativeType Name="clang::VarTemplatePartialSpecializationDecl" Inheritable="false" />
        <AlternativeType Name="clang::VarTemplateSpecializationDecl" Inheritable="false" />
        <Intrinsic Category="Data" Name="is_vtpsd" Expression="get_kind() == Decl::VarTemplatePartialSpecialization" />
        <Intrinsic Category="Data" Name="as_vtpsd" Expression="(VarTemplatePartialSpecializationDecl*)this" />
        <Intrinsic Category="Data" Name="is_vtsd" Expression="get_kind() == Decl::VarTemplateSpecialization || is_vtpsd()" />
        <Intrinsic Category="Data" Name="as_vtsd" Expression="(VarTemplateSpecializationDecl*)this" />

        <DisplayString>{(DeclaratorDecl*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(DeclaratorDecl*)this,nd</ExpandedItem>

            <Item Name="TemplateParams" Optional="true">TemplateParams,na</Item>
            <Item Name="TemplateArgs" Optional="true">TemplateArgs,na</Item>

            <Item Name="SpecializationKind" Optional="true">
                clang::TemplateSpecializationKind(SpecializationKind),en
            </Item>

            <Item Name="SpecializationType" Optional="true" Condition="ExplicitInfo">ExplicitInfo-&gt;TypeAsWritten</Item>


            <!-- KRYSTIAN TODO: this is stored in a DenseMap in ASTContext...
            <Item Name="SpecializationKind" Condition="! is_vtsd() &amp;&amp; ! TemplateOrInstantiation.is_null() &amp;&amp; TemplateOrInstantiation.get_int() == 1">
                clang::TemplateSpecializationKind(
                    ((MemberSpecializationInfo*)TemplateOrInstantiation.get_ptr())-&gt;MemberAndTSK.get_int() + 1),en
            </Item>
            -->

            <!-- KRYSTIAN TODO: this is stored in a DenseMap in ASTContext...
            <Item Name="DescribedTemplate" Condition="! TemplateOrInstantiation.is_null() &amp;&amp; TemplateOrInstantiation.get_int() == 0">
                (VarTemplateDecl*)TemplateOrInstantiation.get_ptr()
            </Item>
            <Item Name="MemberSpecialization" Condition="! TemplateOrInstantiation.is_null() &amp;&amp; TemplateOrInstantiation.get_int() == 1">
                (MemberSpecializationInfo*)TemplateOrInstantiation.get_ptr()
            </Item>
            -->

            <Item Name="IsMemberSpecialization" Optional="true">InstantiatedFromMember.get_int()</Item>
            <Item Name="InstantiatedFromMember" Optional="true" Condition="! InstantiatedFromMember.is_null()">
                InstantiatedFromMember.get_ptr()
            </Item>

            <Item Name="SpecializedTemplate" Optional="true" Condition="SpecializedTemplate.get_int() == 0">
                SpecializedTemplate.get_ptr()
            </Item>
            <Item Name="SpecializedPartial" Optional="true" Condition="SpecializedTemplate.get_int() == 1">
                ((VarTemplateSpecializationDecl::SpecializedPartialSpecialization*)(SpecializedTemplate.get_ptr()))-&gt;PartialSpecialization
            </Item>
            <Item Name="PointOfInstantiation" Optional="true">PointOfInstantiation</Item>

            <ExpandedItem>*(redeclarable_base*)this,nd</ExpandedItem>
        </Expand>
    </Type>


    <!-- ================================================================================================ -->

    <Type Name="clang::CXXRecordDecl" Inheritable="false" >
        <AlternativeType Name="clang::ClassTemplatePartialSpecializationDecl" Inheritable="false" />
        <AlternativeType Name="clang::ClassTemplateSpecializationDecl" Inheritable="false" />
        <Intrinsic Category="Data" Name="is_ctpsd" Expression="get_kind() == Decl::ClassTemplatePartialSpecialization" />
        <Intrinsic Category="Data" Name="as_ctpsd" Expression="(ClassTemplatePartialSpecializationDecl*)this" />
        <Intrinsic Category="Data" Name="is_ctsd" Expression="get_kind() == Decl::ClassTemplateSpecialization || is_ctpsd()" />
        <Intrinsic Category="Data" Name="as_ctsd" Expression="(ClassTemplateSpecializationDecl*)this" />

        <DisplayString>{(TagDecl*)this,nand}</DisplayString>
        <Expand>
            <ExpandedItem>*(NamedDecl*)this,nd</ExpandedItem>

            <Item Name="TemplateParams" Optional="true">TemplateParams,na</Item>
            <Item Name="TemplateArgs"  Optional="true">TemplateArgs,na</Item>

            <Item Name="SpecializationKind" Optional="true">
                clang::TemplateSpecializationKind(SpecializationKind),en
            </Item>
            <Item Name="SpecializationKind" Condition="! is_ctsd() &amp;&amp; ! TemplateOrInstantiation.is_null() &amp;&amp; TemplateOrInstantiation.get_int() == 1">
                clang::TemplateSpecializationKind(
                    ((MemberSpecializationInfo*)TemplateOrInstantiation.get_ptr())-&gt;MemberAndTSK.get_int() + 1),en
            </Item>

            <Item Name="DescribedTemplate" Condition="! TemplateOrInstantiation.is_null() &amp;&amp; TemplateOrInstantiation.get_int() == 0">
                (ClassTemplateDecl*)TemplateOrInstantiation.get_ptr()
            </Item>
            <Item Name="MemberSpecialization" Condition="! TemplateOrInstantiation.is_null() &amp;&amp; TemplateOrInstantiation.get_int() == 1">
                (MemberSpecializationInfo*)TemplateOrInstantiation.get_ptr()
            </Item>

            <Item Name="SpecializationType" Optional="true" Condition="ExplicitInfo">ExplicitInfo-&gt;TypeAsWritten</Item>

            <Item Name="IsMemberSpecialization" Optional="true">InstantiatedFromMember.get_int()</Item>
            <Item Name="InstantiatedFromMember" Optional="true" Condition="! InstantiatedFromMember.is_null()">
                as_ctpsd()-&gt;InstantiatedFromMember.get_ptr()
            </Item>

            <Item Name="SpecializedTemplate" Optional="true" Condition="SpecializedTemplate.get_int() == 0">
                (ClassTemplateDecl*)SpecializedTemplate.get_ptr()
            </Item>
            <Item Name="SpecializedPartial" Optional="true" Condition="SpecializedTemplate.get_int() == 1">
                ((ClassTemplateSpecializationDecl::SpecializedPartialSpecialization*)(SpecializedTemplate.get_ptr()))-&gt;PartialSpecialization
            </Item>

            <Item Name="PointOfInstantiation" Optional="true">PointOfInstantiation</Item>

            <ExpandedItem>*(redeclarable_base*)this,nd</ExpandedItem>
            <ExpandedItem>*(DeclContext*)this,nd</ExpandedItem>
        </Expand>
    </Type>

    <!-- ================================================================================================ -->

    <Type Name="clang::DeclAccessPair">
        <Expand>
            <Synthetic Name="[access]">
                <DisplayString Condition="(Ptr &amp; Mask) == clang::AccessSpecifier::AS_public">public</DisplayString>
                <DisplayString Condition="(Ptr &amp; Mask) == clang::AccessSpecifier::AS_protected">protected</DisplayString>
                <DisplayString Condition="(Ptr &amp; Mask) == clang::AccessSpecifier::AS_private">private</DisplayString>
                <DisplayString Condition="(Ptr &amp; Mask) == clang::AccessSpecifier::AS_none">none</DisplayString>
                <DisplayString>invalid</DisplayString>
            </Synthetic>
            <Item Name="[decl]">(NamedDecl*)(Ptr &amp; ~Mask)</Item>
        </Expand>
    </Type>

    <!--

  <Type Name="clang::CXXMethodDecl">
    <DisplayString IncludeView="cpp">{*(clang::FunctionDecl *)this,nd}</DisplayString>
    <DisplayString>Method {{{*this,view(cpp)}}}</DisplayString>
    <Expand>
      <ExpandedItem>*(FunctionDecl*)this,nd</ExpandedItem>
    </Expand>
  </Type>
  <Type Name="clang::CXXConstructorDecl">
    <DisplayString>Constructor {{{Name,view(cpp)}({*(clang::FunctionDecl *)this,view(parm0)nd})}}</DisplayString>
    <Expand>
      <ExpandedItem>*(FunctionDecl*)this,nd</ExpandedItem>
    </Expand>
  </Type>
  <Type Name="clang::CXXDestructorDecl">
    <DisplayString>Destructor {{~{Name,view(cpp)}()}}</DisplayString>
    <Expand>
      <ExpandedItem>*(FunctionDecl*)this,nd</ExpandedItem>
    </Expand>
  </Type>
  <Type Name="clang::TemplateTypeParmDecl">
    <DisplayString IncludeView="TorC" Condition="Typename">typename</DisplayString>
    <DisplayString IncludeView="TorC" Condition="!Typename">class</DisplayString>
    <DisplayString IncludeView="MaybeEllipses" Condition="TypeForDecl == nullptr">(not yet known if parameter pack) </DisplayString>
    <DisplayString IncludeView="MaybeEllipses" Condition="((TemplateTypeParmType *)(((clang::ExtQualsTypeCommonBase *)(((uintptr_t)TypeForDecl->CanonicalType.Value.Value.Data) &amp; ~(uintptr_t)((1 &lt;&lt; 4) - 1)))-&gt;BaseType))->CanTTPTInfo.ParameterPack">...</DisplayString>
    <DisplayString IncludeView="MaybeEllipses" Condition="!((TemplateTypeParmType *)(((clang::ExtQualsTypeCommonBase *)(((uintptr_t)TypeForDecl->CanonicalType.Value.Value.Data) &amp; ~(uintptr_t)((1 &lt;&lt; 4) - 1)))-&gt;BaseType))->CanTTPTInfo.ParameterPack"></DisplayString>
    <DisplayString IncludeView="DefaultArg" Condition="((*(uintptr_t*)DefaultArgument.ValueOrInherited.Val.Value.Data)&amp;3LL) == 0">{(TypeSourceInfo *)((*(uintptr_t*)DefaultArgument.ValueOrInherited.Val.Value.Data)&amp;~3LL),view(cpp)}</DisplayString>
    <DisplayString IncludeView="DefaultArg">{{InheritedInitializer}}</DisplayString>
    <DisplayString IncludeView="Initializer" Condition="(*(uintptr_t*)DefaultArgument.ValueOrInherited.Val.Value.Data)&amp;~3LL">= {this,view(DefaultArg)na}</DisplayString>
    <DisplayString IncludeView="Initializer"></DisplayString>
    <DisplayString>{*this,view(TorC)} {*this,view(MaybeEllipses)}{Name,view(cpp)} {this,view(Initializer)na}</DisplayString>
  </Type>
  <Type Name="clang::TemplateDecl">
    <DisplayString IncludeView="cpp">{*TemplatedDecl,view(cpp)}</DisplayString>
    <DisplayString>template{TemplateParams,na} {*TemplatedDecl};</DisplayString>
    <Expand>
      <ExpandedItem>*(NamedDecl *)this,nd</ExpandedItem>
      <Item Name="TemplateParams">TemplateParams,na</Item>
      <Item Name="TemplatedDecl">TemplatedDecl,na</Item>
    </Expand>
  </Type>
  <Type Name="clang::TypedefNameDecl">
    <DisplayString Condition="(*(uintptr_t *)MaybeModedTInfo.Value.Data &amp; 4)==0" IncludeView="type">{(clang::TypeSourceInfo *)(*(uintptr_t *)MaybeModedTInfo.Value.Data &amp; ~7LL),view(cpp)na}</DisplayString>
    <DisplayString Condition="(*(uintptr_t *)MaybeModedTInfo.Value.Data &amp; 4)!=0" IncludeView="type">{(clang::TypedefNameDecl::ModedTInfo *)(*(uintptr_t *)MaybeModedTInfo.Value.Data &amp; ~7LL),view(cpp)na}</DisplayString>
    <DisplayString IncludeView="name">{(TypeDecl *)this,view(cpp)nand}</DisplayString>
    <DisplayString>typedef {this,view(type)na} {this,view(name)na};</DisplayString>
    <Expand>
      <ExpandedItem>*(TypeDecl *)this,nd</ExpandedItem>
      <Item Name="IsTransparent" Condition="(*(uintptr_t *)MaybeModedTInfo.Value.Data &amp; 1)==0">"Not yet calculated",sb</Item>
      <Item Name="IsTransparent" Condition="(*(uintptr_t *)MaybeModedTInfo.Value.Data &amp; 1)!=0">(bool)(*(uintptr_t *)MaybeModedTInfo.Value.Data &amp; 2)</Item>
      <Item Name="TypeSourceInfo" Condition="(*(uintptr_t *)MaybeModedTInfo.Value.Data &amp; 4)==0">(clang::TypeSourceInfo *)(*(uintptr_t *)MaybeModedTInfo.Value.Data &amp; ~7LL)</Item>
      <Item Name="ModedTInfo" Condition="(*(uintptr_t *)MaybeModedTInfo.Value.Data &amp; 4)!=0">(clang::TypedefNameDecl::ModedTInfo *)(*(uintptr_t *)MaybeModedTInfo.Value.Data &amp; ~7LL)</Item>
    </Expand>
  </Type>
  <Type Name="clang::TypeAliasDecl">
    <DisplayString IncludeView="cpp">{(TypedefNameDecl *)this,view(name)nand}</DisplayString>
    <DisplayString>using {(TypedefNameDecl *)this,view(name)nand} = {(TypedefNameDecl *)this,view(type)nand}</DisplayString>
  </Type>

  <Type Name="clang::TagDecl">
    <DisplayString IncludeView="implicit" Condition="Implicit">implicit{" ",sb}</DisplayString>
    <DisplayString IncludeView="implicit"></DisplayString>
    <DisplayString IncludeView="modifiers">{*this,view(implicit)nd}</DisplayString>
    <DisplayString IncludeView="cpp">{*this,view(modifiers)}{Name,view(cpp)}</DisplayString>
    <DisplayString Condition="TagDeclBits.TagDeclKind==clang::TagTypeKind::TTK_Struct">{*this,view(modifiers)nd}struct {Name,view(cpp)}</DisplayString>
    <DisplayString Condition="TagDeclBits.TagDeclKind==clang::TagTypeKind::TTK_Interface">{*this,view(modifiers)nd}interface {Name,view(cpp)}</DisplayString>
    <DisplayString Condition="TagDeclBits.TagDeclKind==clang::TagTypeKind::TTK_Union">{*this,view(modifiers)nd}union {Name,view(cpp)}</DisplayString>
    <DisplayString Condition="TagDeclBits.TagDeclKind==clang::TagTypeKind::TTK_Class">{*this,view(modifiers)nd}class {Name,view(cpp)}</DisplayString>
    <DisplayString Condition="TagDeclBits.TagDeclKind==clang::TagTypeKind::TTK_Enum">{*this,view(modifiers)nd}enum {Name,view(cpp)}</DisplayString>
    <Expand>
      <ExpandedItem>*(clang::Decl *)this,nd</ExpandedItem>
    </Expand>
  </Type>

  <Type Name="clang::VarDecl::VarDeclBitfields">
    <Expand>
      <Item Name="StorageClass">(clang::StorageClass)SClass</Item>
      <Item Name="ThreadStorageClass">(clang::ThreadStorageClassSpecifier)TSCSpec</Item>
      <Item Name="InitStyle">(clang::VarDecl::InitializationStyle)InitStyle</Item>
    </Expand>
  </Type>
  <Type Name="clang::DeclaratorDecl">
    <DisplayString>{DeclType,view(left)} {Name,view(cpp)}{DeclType,view(right)}</DisplayString>
    <Expand>
      <ExpandedItem>*(NamedDecl*)this,nd</ExpandedItem>
      <Item Name="DeclType">DeclType</Item>
    </Expand>
  </Type>
  <Type Name="clang::VarDecl">
    <DisplayString>{(DeclaratorDecl*)this,nand}</DisplayString>
    <Expand>
      <ExpandedItem>*(DeclaratorDecl*)this,nd</ExpandedItem>
      <Item Name="Init">Init</Item>
      <Item Name="VarDeclBits">VarDeclBits</Item>
    </Expand>
  </Type>
  <Type Name="clang::ParmVarDecl">
    <DisplayString>{*(VarDecl*)this,nd}</DisplayString>
    <Expand>
      <Item Name="ParmVarDeclBits">ParmVarDeclBits</Item>
      <ExpandedItem>*(VarDecl*)this,nd</ExpandedItem>
    </Expand>
  </Type>
  <Type Name="clang::ExplicitSpecifier">
    <DisplayString Condition="((*(uintptr_t *)ExplicitSpec.Value.Data&gt;&gt;1)&amp;3) == ExplicitSpecKind::ResolvedTrue" IncludeView="cpp">{"explicit ",sb}</DisplayString>
    <DisplayString Condition="((*(uintptr_t *)ExplicitSpec.Value.Data&gt;&gt;1)&amp;3) == ExplicitSpecKind::ResolvedFalse" IncludeView="cpp"></DisplayString>
    <DisplayString Condition="((*(uintptr_t *)ExplicitSpec.Value.Data&gt;&gt;1)&amp;3) == ExplicitSpecKind::Unresolved" IncludeView="cpp">explicit({ExplicitSpec,view(ptr)na})</DisplayString>
    <DisplayString Condition="((*(uintptr_t *)ExplicitSpec.Value.Data)&amp;~7) == 0">{ExplicitSpec,view(int)en}</DisplayString>
    <DisplayString>{ExplicitSpec,view(int)en} : {ExplicitSpec,view(ptr)na}</DisplayString>
  </Type>
  <Type Name="clang::CXXDeductionGuideDecl">
    <DisplayString>{ExplicitSpec,view(cpp)}{Name,view(cpp)nd}({(FunctionDecl*)this,view(parm0)nand}) -&gt; {((clang::FunctionProtoType *)((clang::ExtQualsTypeCommonBase *)(((uintptr_t)DeclType.Value.Value) &amp; ~15))-&gt;BaseType)->ResultType,view(cpp)}</DisplayString>
    <Expand>
      <Item Name="ExplicitSpec">ExplicitSpec</Item>
      <Item Name="IsCopyDeductionCandidate">(bool)FunctionDeclBits.IsCopyDeductionCandidate</Item>
      <ExpandedItem>(FunctionDecl*)this,nd</ExpandedItem>
    </Expand>
  </Type>

  <Type Name="clang::FriendDecl">
    <DisplayString>{(Decl*)this,nand}</DisplayString>
    <Expand>
      <ExpandedItem>*(Decl*)this,nd</ExpandedItem>
      <Item Name="Friend">Friend</Item>
    </Expand>
  </Type>

  <Type Name="clang::ClassScopeFunctionSpecializationDecl">
    <DisplayString>{(Decl*)this,nand}</DisplayString>
    <Expand>
      <ExpandedItem>*(Decl*)this,nd</ExpandedItem>
      <Item Name="TemplateArgs">TemplateArgs</Item>
      <Item Name="Specialization">Specialization</Item>
    </Expand>
  </Type>

  <Type Name="clang::FunctionDecl">
    <DisplayString IncludeView="retType">{((clang::FunctionProtoType *)((clang::ExtQualsTypeCommonBase *)((*(uintptr_t *)DeclType.Value.Value.Data) &amp; ~15))-&gt;BaseType)->ResultType,view(cpp)}</DisplayString>
    <DisplayString IncludeView="parm0" Condition="0 == ((clang::FunctionProtoType *)((clang::ExtQualsTypeCommonBase *)((*(uintptr_t *)DeclType.Value.Value.Data) &amp; ~15))-&gt;BaseType)-&gt;FunctionTypeBits.NumParams"></DisplayString>
    <DisplayString IncludeView="parm0">{ParamInfo[0],na}{*this,view(parm1)nd}</DisplayString>
    <DisplayString IncludeView="parm1" Condition="1 == ((clang::FunctionProtoType *)((clang::ExtQualsTypeCommonBase *)((*(uintptr_t *)DeclType.Value.Value.Data) &amp; ~15))-&gt;BaseType)-&gt;FunctionTypeBits.NumParams"></DisplayString>
    <DisplayString IncludeView="parm1">, {ParamInfo[1],na}{*this,view(parm2)nd}</DisplayString>
    <DisplayString IncludeView="parm2" Condition="2 == ((clang::FunctionProtoType *)((clang::ExtQualsTypeCommonBase *)((*(uintptr_t *)DeclType.Value.Value.Data) &amp; ~15))-&gt;BaseType)-&gt;FunctionTypeBits.NumParams"></DisplayString>
    <DisplayString IncludeView="parm2">, {ParamInfo[2],na}{*this,view(parm3)nd}</DisplayString>
    <DisplayString IncludeView="parm3" Condition="3 == ((clang::FunctionProtoType *)((clang::ExtQualsTypeCommonBase *)((*(uintptr_t *)DeclType.Value.Value.Data) &amp; ~15))-&gt;BaseType)-&gt;FunctionTypeBits.NumParams"></DisplayString>
    <DisplayString IncludeView="parm3">, {ParamInfo[3],na}{*this,view(parm4)nd}</DisplayString>
    <DisplayString IncludeView="parm4" Condition="4 == ((clang::FunctionProtoType *)((clang::ExtQualsTypeCommonBase *)((*(uintptr_t *)DeclType.Value.Value.Data) &amp; ~15))-&gt;BaseType)-&gt;FunctionTypeBits.NumParams"></DisplayString>
    <DisplayString IncludeView="parm4">, {ParamInfo[4],na}{*this,view(parm5)nd}</DisplayString>
    <DisplayString IncludeView="parm5" Condition="5 == ((clang::FunctionProtoType *)((clang::ExtQualsTypeCommonBase *)((*(uintptr_t *)DeclType.Value.Value.Data) &amp; ~15))-&gt;BaseType)-&gt;FunctionTypeBits.NumParams"></DisplayString>
    <DisplayString IncludeView="parm5">, /* expand for more params */</DisplayString>
    <DisplayString Condition="((clang::FunctionProtoType *)((clang::ExtQualsTypeCommonBase *)((*(uintptr_t *)DeclType.Value.Value.Data) &amp; ~15))-&gt;BaseType)-&gt;FunctionTypeBits.HasTrailingReturn">
      auto {Name,view(cpp)nd}({*this,view(parm0)nd}) -&gt; {((clang::FunctionProtoType *)((clang::ExtQualsTypeCommonBase *)((*(uintptr_t *)DeclType.Value.Value.Data) &amp; ~15))-&gt;BaseType)->ResultType,view(cpp)}
    </DisplayString>
    <DisplayString>{this,view(retType)nand} {Name,view(cpp)nd}({*this,view(parm0)nd})</DisplayString>
    <Expand>
      <ExpandedItem>(clang::DeclaratorDecl *)this,nd</ExpandedItem>
      <ExpandedItem>(clang::Redeclarable&lt;clang::FunctionDecl&gt; *)this,nd</ExpandedItem>
      <Item Name="ReturnType">((clang::FunctionProtoType *)((clang::ExtQualsTypeCommonBase *)((*(uintptr_t *)DeclType.Value.Value.Data) &amp; ~15))-&gt;BaseType)->ResultType</Item>
      <Synthetic Name="Parameter Types">
        <DisplayString>{*this,view(parm0)nd}</DisplayString>
        <Expand>
          <ArrayItems>
            <Size>((clang::FunctionProtoType *)((clang::ExtQualsTypeCommonBase *)((*(uintptr_t *)DeclType.Value.Value.Data) &amp; ~15))-&gt;BaseType)-&gt;FunctionTypeBits.NumParams</Size>
            <ValuePointer>ParamInfo</ValuePointer>
          </ArrayItems>
        </Expand>
      </Synthetic>
      <Item Name="TemplateOrSpecialization">TemplateOrSpecialization</Item>
    </Expand>
  </Type>
  -->




    <!--
  <Type Name="clang::DeclAccessPair">
    <DisplayString IncludeView="access" Condition="(Ptr&amp;Mask) == clang::AS_public">public</DisplayString>
    <DisplayString IncludeView="access" Condition="(Ptr&amp;Mask) == clang::AS_protected">protected</DisplayString>
    <DisplayString IncludeView="access" Condition="(Ptr&amp;Mask) == clang::AS_private">private</DisplayString>
    <DisplayString IncludeView="access" Condition="(Ptr&amp;Mask) == clang::AS_none"></DisplayString>
    <DisplayString IncludeView="decl">{*(clang::NamedDecl *)(Ptr&amp;~Mask)}</DisplayString>
    <DisplayString>{*this,view(access)} {*this,view(decl)}</DisplayString>
    <Expand>
      <Item Name="access">(clang::AccessSpecifier)(Ptr&amp;Mask),en</Item>
      <Item Name="decl">*(clang::NamedDecl *)(Ptr&amp;~Mask)</Item>
    </Expand>
  </Type>

  <Type Name="clang::DeclGroup">
    <DisplayString>NumDecls={NumDecls}</DisplayString>
    <Expand>
      <ArrayItems>
        <Size>NumDecls</Size>
        <ValuePointer>(Decl **)(this+1)</ValuePointer>
      </ArrayItems>
    </Expand>
  </Type>
  <Type Name="clang::DeclGroupRef">
    <DisplayString Condition="(Kind)((uintptr_t)D&amp;1)==SingleDeclKind">{*D}</DisplayString>
    <DisplayString>{*(DeclGroup *)((uintptr_t)D&amp;~1)}</DisplayString>
    <Expand>
      <ExpandedItem Condition="(Kind)((uintptr_t)D&amp;1)==SingleDeclKind">D</ExpandedItem>
      <ExpandedItem Condition="(Kind)((uintptr_t)D&amp;1)==DeclGroupKind">(DeclGroup *)((uintptr_t)D&amp;~1)</ExpandedItem>
    </Expand>
  </Type>
  -->

</AutoVisualizer>
