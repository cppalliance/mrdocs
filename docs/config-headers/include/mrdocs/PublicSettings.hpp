/*
 * This file is generated automatically from the json file
 * `src/lib/Lib/ConfigOptions.json`. Do not edit this file
 * manually. Instead, edit the json file and run the script
 * `util/generate-config-info.py` to regenerate this file.
 */

#ifndef MRDOCS_PUBLIC_SETTINGS_HPP
#define MRDOCS_PUBLIC_SETTINGS_HPP

#include <mrdocs/Support/Glob.hpp>
#include <mrdocs/Support/Error.hpp>
#include <mrdocs/Config/ReferenceDirectories.hpp>
#include <string>
#include <vector>
#include <optional>
#include <variant>
#include <map>

namespace clang::mrdocs {

struct PublicSettings {
    //--------------------------------------------
    // Enums
    //--------------------------------------------

    /** Enum for "generator" options
    
        This enumeration value is valid for the `generator` option

     */
    enum class Generator {
        Adoc,
        Html,
        Xml,
    };

    static
    constexpr
    std::string_view
    toString(Generator const e) {
        switch (e) {
             case Generator::Adoc:
                  return "adoc";
             case Generator::Html:
                  return "html";
             case Generator::Xml:
                  return "xml";
        }
        return "";
    }

    static
    constexpr
    bool
    fromString(std::string_view const str, Generator& e) {
        if (str == "adoc")
        {
            e = Generator::Adoc;
            return true;
        }
        if (str == "html")
        {
            e = Generator::Html;
            return true;
        }
        if (str == "xml")
        {
            e = Generator::Xml;
            return true;
        }
        return false;
    }

    /** Enum for "log-level" options
    
        This enumeration value is valid for the `log-level` option

     */
    enum class LogLevel {
        Trace,
        Debug,
        Info,
        Warn,
        Error,
        Fatal,
    };

    static
    constexpr
    std::string_view
    toString(LogLevel const e) {
        switch (e) {
             case LogLevel::Trace:
                  return "trace";
             case LogLevel::Debug:
                  return "debug";
             case LogLevel::Info:
                  return "info";
             case LogLevel::Warn:
                  return "warn";
             case LogLevel::Error:
                  return "error";
             case LogLevel::Fatal:
                  return "fatal";
        }
        return "";
    }

    static
    constexpr
    bool
    fromString(std::string_view const str, LogLevel& e) {
        if (str == "trace")
        {
            e = LogLevel::Trace;
            return true;
        }
        if (str == "debug")
        {
            e = LogLevel::Debug;
            return true;
        }
        if (str == "info")
        {
            e = LogLevel::Info;
            return true;
        }
        if (str == "warn")
        {
            e = LogLevel::Warn;
            return true;
        }
        if (str == "error")
        {
            e = LogLevel::Error;
            return true;
        }
        if (str == "fatal")
        {
            e = LogLevel::Fatal;
            return true;
        }
        return false;
    }

    /** Enum for "base-member-inheritance" options
    
        This enumeration value is valid for the `inherit-base-members` option

     */
    enum class BaseMemberInheritance {
        Never,
        Reference,
        CopyDependencies,
        CopyAll,
    };

    static
    constexpr
    std::string_view
    toString(BaseMemberInheritance const e) {
        switch (e) {
             case BaseMemberInheritance::Never:
                  return "never";
             case BaseMemberInheritance::Reference:
                  return "reference";
             case BaseMemberInheritance::CopyDependencies:
                  return "copy-dependencies";
             case BaseMemberInheritance::CopyAll:
                  return "copy-all";
        }
        return "";
    }

    static
    constexpr
    bool
    fromString(std::string_view const str, BaseMemberInheritance& e) {
        if (str == "never")
        {
            e = BaseMemberInheritance::Never;
            return true;
        }
        if (str == "reference")
        {
            e = BaseMemberInheritance::Reference;
            return true;
        }
        if (str == "copy-dependencies")
        {
            e = BaseMemberInheritance::CopyDependencies;
            return true;
        }
        if (str == "copy-all")
        {
            e = BaseMemberInheritance::CopyAll;
            return true;
        }
        return false;
    }

    /** Enum for "sort-symbol-by" options
    
        These enumeration values are valid for the following options:

        - sort-members-by
        - sort-namespace-members-by

     */
    enum class SortSymbolBy {
        Name,
        Location,
    };

    static
    constexpr
    std::string_view
    toString(SortSymbolBy const e) {
        switch (e) {
             case SortSymbolBy::Name:
                  return "name";
             case SortSymbolBy::Location:
                  return "location";
        }
        return "";
    }

    static
    constexpr
    bool
    fromString(std::string_view const str, SortSymbolBy& e) {
        if (str == "name")
        {
            e = SortSymbolBy::Name;
            return true;
        }
        if (str == "location")
        {
            e = SortSymbolBy::Location;
            return true;
        }
        return false;
    }

    //--------------------------------------------
    // Command Line Options
    // 
    // Options that can only be provided via the command line
    //--------------------------------------------

    /** Configuration or compilation database files
    
        The inputs are configuration files or compilation database files that
        used to generate the documentation.
        
        When the input ends with `mrdocs.yml`, it is interpreted as a
        configuration file, the file is read and the options are used to
        generate the documentation as if it was provided to the `config`
        option.
        
        When the input ends with `compilation_database.json` or
        `CMakeLists.txt`, it is interpreted as a compilation database file,
        the file is read and the compiler flags are used to generate the
        documentation as if it was provided to the `compilation-database`
        option.
     */
    std::vector<std::string> cmdLineInputs;

    /** Mr.Docs configuration file
    
        The configuration file is a YAML file that contains the options used
        to generate the documentation.
        
        The configuration file is read and the options are used to generate
        the documentation.
        
        The configuration file can be used to specify the source code, the
        output directory, the compilation database, the generator, and the
        filters.
     */
    std::string config;

    //--------------------------------------------
    // Paths
    // 
    // Paths to the source code and output directories
    //--------------------------------------------

    /** Path to the root directory of the source code
    
        Path to the root directory of the source code.
        
        This path is used as a default for input files and a base for relative
        paths formed from absolute paths.
        
        This should typically be the root directory of the git project, as
        relative paths formed from it can be used to create links to these
        source files in the repository.
        
        Templates use the `base-url` option to create links to the source
        code.
     */
    std::string sourceRoot;

    /** Directory or file for generating output
    
        Multipage generators expect a directory.
        
        Single page generators expect a file or a directory where the file
        will be created.
        
        If the directory does not exist, it will be created.
     */
    std::string output;

    /** Path to the compilation database
    
        Path to the compilation database or a build script to generate it.
        
        The compilation database is a JSON file that contains the compiler
        commands used to build the source code.
        
        The compilation database is used to extract the compiler flags and the
        source files used to build the source code and extract symbols.
        
        This option also accepts the path to a build script such as
        CMakeLists.txt to be used to generate the compilation database.
        
        In this case, Mr.Docs will look for CMake in `PATH` or in `CMAKE_ROOT`
        and run the script to generate the compilation database file.
     */
    std::string compilationDatabase;

    //--------------------------------------------
    // Filters
    // 
    // Filters to include or exclude files and symbols from the documentation
    //--------------------------------------------

    /** Input directories to extract symbols from
    
        Input directories to extract.
        
        Only symbols defined in files in these directories are extracted.
        
        The paths are relative to the mrdocs configuration file.
     */
    std::vector<std::string> input;

    /** Recursively include files from "input" paths
    
        Recursively include files.
        
        When set to true, Mr.Docs includes files in subdirectories of the
        input directories.
        
        When set to false, Mr.Docs includes only the files in the input
        directories.
     */
    bool recursive = true;

    /** File patterns to include
    
        File patterns to include.
        
        Only the files that match these patterns are extracted.
        
        The patterns are relative to the input directories.
     */
    std::vector<PathGlobPattern> filePatterns;

    /** Input directories to exclude
    
        Symbols defined in files in these directories are not extracted even
        if they are in the list of include directories.
        
        When relative, the paths are relative to the directory of the mrdocs
        configuration file.
        
        For instance, "include/experimental" will exclude all files in the
        directory `<config-dir>/include/experimental`.
     */
    std::vector<std::string> exclude;

    /** File patterns to exclude
    
        File patterns to exclude.
        
        Files that match these patterns are not extracted even if they are in
        the list of include directories.
        
        The patterns are relative to the configuration file.
        
        A single * will match all files in the directory.
        
        Double ** will match all files in the directory and its
        subdirectories.
     */
    std::vector<PathGlobPattern> excludePatterns;

    /** Symbol patterns to include
    
        If any patterns are defined here, only symbols that match one of these
        patterns are extracted.
        
        The patterns are applied to the fully qualified name of the symbol
        without any leading "::".
        
        A single "*" will match all symbols in the namespace.
        
        Double "**" will match all symbols in the namespace and its
        subnamespaces.
        
        The patterns also support "?" for any chars, "[<chars>]" for charsets,
        "[^<chars>]" for inverted charsets, and "{<glob>,...}" for
        alternatives.
     */
    std::vector<SymbolGlobPattern> includeSymbols;

    /** Symbol patterns to exclude
    
        A symbol that matches one of these patterns is not extracted even if
        whitelisted by "include-symbols".
        
        See the documentation for "include-symbols" for the pattern syntax.
     */
    std::vector<SymbolGlobPattern> excludeSymbols;

    /** Exposition only symbols rendered as "see-below".
    
        Symbols that match one of these filters are tagged as "see-below" in
        the documentation, and so do symbols in scopes tagged as "see-below".
        
        This option is used to remove details about symbols that are
        considered part of the private API of the project but the user might
        need to interact with.
        
        In the documentation page for this symbol, the symbol is exposition
        only: the synopsis of the implementation is rendered as "see-below"
        and members of scopes (such as a namespace or record) are not listed.
        
        The rest of the documentation is rendered as usual to explain the
        symbol.
        
        See the documentation for "include-symbol" for the pattern syntax.
     */
    std::vector<SymbolGlobPattern> seeBelow;

    /** Symbols rendered as "implementation-defined"
    
        Symbols that match one of these filters are tagged as
        "implementation-defined" in the documentation, and so do symbols in
        scopes tagged as "implementation-defined".
        
        This option is used to exclude symbols from the documentation that are
        considered part of the private API of the project.
        
        An "implementation-defined" symbol has no documentation page in the
        output.
        
        If any other symbol refers to it, the reference is rendered as
        "implementation-defined".
        
        See the documentation for "include-symbol" for the pattern syntax.
     */
    std::vector<SymbolGlobPattern> implementationDefined;

    //--------------------------------------------
    // Comment Parsing
    // 
    // Options to control how comments are parsed
    //--------------------------------------------

    /** Use the first line of the comment as the brief
    
        When set to `true`, Mr.Docs uses the first line (until the first dot,
        question mark, or exclamation mark) of the comment as the brief of the
        symbol.
        
        When set to `false`, a explicit @brief command is required.
     */
    bool autoBrief = true;

    /** Automatically find non-member functions
    
        When set to `true`, Mr.Docs automatically finds non-member functions
        that are related to the current class.
     */
    bool autoRelates = true;

    /** Automatically provide missing documentation for special functions
        and trivial metadata
    
        When set to `true`, Mr.Docs automatically provides documentation for
        special functions, such as constructors, destructors, and operators.
        
        It also provides documentation for missing documentation metadata,
        such as known types.
     */
    bool autoFunctionMetadata = true;

    //--------------------------------------------
    // Metadata Extraction
    // 
    // Metadata and C++ semantic constructs to extract
    //--------------------------------------------

    /** Extract all symbols
    
        When set to `true`, MrDocs extracts all symbols from the source code,
        even if no documentation is provided.
        
        MrDocs can only identify whether a symbol is ultimated documented
        after extracting information from all translation units.
        
        For this reason, when this option is set to `false`, it's still
        recommendable to provide file and symbol filters so that only the
        desired symbols are traversed and stored by MrDocs.
     */
    bool extractAll = true;

    /** Extraction policy for private class members
    
        Determine whether private class members should be extracted
     */
    bool extractPrivate = false;

    /** Extraction policy for private virtual methods of a class
    
        Determine whether private virtual methods of a class should be
        extracted
     */
    bool extractPrivateVirtual = false;

    /** Extraction policy for private base classes
    
        Determine whether private base classes should be extracted
     */
    bool extractPrivateBases = false;

    /** Extraction policy for static members of a file
    
        Determine whether static members of a file should be extracted.
        
        This option does not refer to static members of a class.
     */
    bool extractStatic = false;

    /** Extraction policy for records defined locally in source files
    
        Determine whether records only defined locally in source files should
        be extracted.
     */
    bool extractLocalClasses = true;

    /** Extraction policy for anonymous namespaces
    
        Determine whether symbols in anonymous namespaces should be extracted.
     */
    bool extractAnonymousNamespaces = true;

    /** Extraction policy for empty namespaces
    
        Determine whether empty namespaces without documentation should be
        extracted.
     */
    bool extractEmptyNamespaces = false;

    /** Determine how derived classes inherit base members
    
        Determine how derived classes inherit members of base classes.
        
        When set to `never`, derived classes do not inherit members of base
        classes and only the relationship is stored.
        
        When set to `reference`, derived classes list members of base classes
        but references are still linked to the base class.
        
        When set to `copy-dependencies`, a reference is created by default and
        a copy is created when the base class is a dependency.
        
        When set to `copy-all`, a copy is created for each base symbol as if
        it was declared in the derived class.
        
        If the base class is a dependency, the extraction mode is copied from
        the new parent.
     */
    BaseMemberInheritance inheritBaseMembers = BaseMemberInheritance::CopyDependencies;

    /** Implicit template specializations used as base classes are
        extracted as dependencies
    
        When set to `true`, MrDocs extracts implicit template specializations
        used as base classes as dependencies.
        
        This allows MrDocs to extract metadata that can later be used to
        determine the members of the derived class, as specified by the
        `inherit-base-members` option.
     */
    bool extractImplicitSpecializations = true;

    /** Extraction policy for friend functions and classes
    
        Determine whether friend functions and classes should be extracted.
        
        When set to `true`, MrDocs extracts friend functions and classes.
        
        When set to `false`, friend functions and classes are not extracted.
     */
    bool extractFriends = true;

    /** Sort the members of a record
    
        When set to `true`, sort the members of a record by the criterion
        determined in the `sort-members-by` option.
        
        When set to `false`, the members are included in the declaration order
        they are extracted.
     */
    bool sortMembers = true;

    /** Determine how members of a record are sorted
    
        If `sort-members` is set to `true`, determine how members of a record
        are sorted.
        
        When set to `name`, members are sorted by name.
        
        When set to `location`, members are sorted by their primary location
        in the source code, considering the short name of the path and the
        location in the file.
     */
    SortSymbolBy sortMembersBy = SortSymbolBy::Name;

    /** Determine how members of a namespace are sorted
    
        Although members of namespaces are always sorted, determine how
        members of a namespace are sorted.
        
        When set to `name`, members are sorted by name.
        
        When set to `location`, members are sorted by their primary location
        in the source code, considering the short name of the path and the
        location in the file.
     */
    SortSymbolBy sortNamespaceMembersBy = SortSymbolBy::Name;

    /** Sort constructors first
    
        When set to `true`, constructors are sorted first in the list of
        members of a record.
     */
    bool sortMembersCtors1St = true;

    /** Sort destructors first
    
        When set to `true`, destructors are sorted first in the list of
        members of a record.
     */
    bool sortMembersDtors1St = true;

    /** Sort assignment operators first
    
        When set to `true`, assignment operators are sorted first in the list
        of members of a record.
     */
    bool sortMembersAssignment1St = true;

    /** Sort conversion operators last
    
        When set to `true`, conversion operators are sorted last in the list
        of members of a record or namespace.
     */
    bool sortMembersConversionLast = true;

    /** Sort relational operators last
    
        When set to `true`, relational operators are sorted last in the list
        of members of a record or namespace.
     */
    bool sortMembersRelationalLast = true;

    //--------------------------------------------
    // Semantic Constructs
    // 
    // C++ semantic constructs to extract
    //--------------------------------------------

    /** Detect and reduce SFINAE expressions
    
        When set to true, MrDocs detects SFINAE expressions in the source code
        and extracts them as part of the documentation.
        
        Expressions such as `std::enable_if<...>` are detected, removed, and
        documented as a requirement.
        
        MrDocs uses an algorithm that extracts SFINAE infomation from types by
        identifying inspecting the primary template and specializations to
        detect the result type and the controlling expressions in a
        specialization.
     */
    bool sfinae = true;

    /** Detect and group function overloads
    
        When set to `true`, MrDocs detects function overloads and groups them
        as a single symbol type.
        
        The documentation for this new symbol comes from the union of
        non-ambiguous metadata from the functions.
     */
    bool overloads = true;

    //--------------------------------------------
    // Generators
    // 
    // Generators to create the documentation and their options
    //--------------------------------------------

    /** Generator used to create the documentation
    
        The generator is responsible for creating the documentation from the
        extracted symbols.
        
        The generator uses the extracted symbols and the templates to create
        the documentation.
        
        The generator can create different types of documentation such as
        HTML, XML, and AsciiDoc.
     */
    Generator generator = Generator::Adoc;

    /** Generate a multipage documentation
    
        Generates a multipage documentation.
        
        The output directory must be a directory.
        
        This option acts as a hint to the generator to create a multipage
        documentation.
        
        Whether the hint is followed or not depends on the generator.
     */
    bool multipage = true;

    /** Base URL for links to source code
    
        Base URL for links to source code.
        
        The base URL is used to create links to the source code in the
        documentation.
        
        The base URL is combined with the path to the source file to create
        the link.
     */
    std::string baseUrl;

    /** Path to the Addons directory
    
        Path to the Addons directory.
        
        The Addons directory contains the template files used by generators to
        create the documentation.
        
        When a custom Addons directory is not specified, the default templates
        are used.
        
        The default templates are located at the `share/mrdocs/addons`
        directory of the MrDocs installation.
        
        Users can create custom templates by copying the default templates to
        a custom directory and specifying the custom directory using this
        option.
     */
    std::string addons;

    /** Path for the tagfile
    
        Specifies the full path (filename) where the generated tagfile should
        be saved.
        
        If left empty, no tagfile will be generated.
     */
    std::string tagfile;

    /** Use legible names
    
        Use legible names for ids in the documentation.
        
        When set to true, MrDocs uses legible names for symbols in the
        documentation.
        
        These are symbols that are legible but still safe for URLs.
        
        When the option is set to false, MrDocs uses a hash of the symbol ID.
     */
    bool legibleNames = true;

    /** Output an embeddable document
    
        Output an embeddable document, which excludes the header, the footer,
        and everything outside the body of the document.
        
        This option is useful for producing documents that can be inserted
        into an external template.
     */
    bool embedded = false;

    /** Show namespace pages in the documentation
    
        When set to true, MrDocs creates a page for each namespace in the
        documentation.
     */
    bool showNamespaces = true;

    /** Use the global namespace page as an index for all symbols
    
        When set to true, the page for the global namespace will recursively
        list all symbols in the documentation, not just those in the global
        namespace.
        
        This makes the global namespace page act as an index for the entire
        project.
     */
    bool globalNamespaceIndex = true;

    //--------------------------------------------
    // Build options
    // 
    // Options for building the source code
    //--------------------------------------------

    /** CMake arguments when generating the compilation database from
        CMakeLists.txt
    
        When the compilation-database option is a CMakeLists.txt file, these
        arguments are passed to the cmake command to generate the
        compilation_database.json.
     */
    std::string cmake;

    /** Additional defines passed to the compiler
    
        Additional defines passed to the compiler when building the source
        code.
        
        These defines are added to the compilation database regardless of the
        strategy to generate it.
     */
    std::vector<std::string> defines;

    /** Use the system C++ standard library
    
        To achieve reproducible results, MrDocs bundles the LibC++ headers.
        
        To use the C++ standard library available in the system instead, set
        this option to true.
     */
    bool useSystemStdlib = false;

    /** C++ Standard Library include paths
    
        When `use-system-stdlib` is disabled, the C++ standard library headers
        are available in these paths.
     */
    std::vector<std::string> stdlibIncludes;

    /** Use the system C standard library
    
        To achieve reproducible results, MrDocs bundles the LibC headers with
        its definitions.
        
        To use the C standard library available in the system instead, set
        this option to true.
     */
    bool useSystemLibc = false;

    /** Standard Library include paths
    
        When `use-system-libc` is disabled, the C standard library headers are
        available in these paths.
     */
    std::vector<std::string> libcIncludes;

    /** System include paths
    
        System include paths.
        
        These paths are used to add directories to the system include search
        path.
        
        The system include search path is used to search for system headers.
        
        The system headers are headers that are provided by the system and are
        not part of the project.
        
        The system headers are used to provide the standard library headers
        and other system headers.
        
        The system headers are not part of the project and are not checked for
        warnings and errors.
     */
    std::vector<std::string> systemIncludes;

    /** Include paths
    
        Include paths.
        
        These paths are used to add directories to the include search path.
        
        The include search path is used to search for headers.
        
        The headers are used to provide declarations and definitions of
        symbols.
        
        The headers are part of the project and are checked for warnings and
        errors.
     */
    std::vector<std::string> includes;

    //--------------------------------------------
    // Warnings
    // 
    // Warnings and progress messages
    //--------------------------------------------

    /** Verbose output
    
        Verbose output.
        
        When set to true, MrDocs outputs additional information during the
        generation of the documentation.
     */
    bool verbose = false;

    /** The minimum reporting level
    
        The reporting level determines the amount of information displayed
        during the generation of the documentation.
        
        The value `-1` delegates the decision to the `log-level` option.
     */
    unsigned report = -1;

    /** The minimum reporting level
    
        The reporting level determines the amount of information displayed
        during the generation of the documentation.
     */
    LogLevel logLevel = LogLevel::Info;

    /** Enable warning messages
    
        When set to `true`, MrDocs outputs warning messages during the
        generation of the documentation.
        
        It is usually recommended to enable warnings while writing the
        documentation.
     */
    bool warnings = true;

    /** Warn if symbols are not documented
    
        When set to `true`, MrDocs outputs a warning message if a symbol that
        passes all filters is not documented.
     */
    bool warnIfUndocumented = true;

    /** Warn if documentation has errors
    
        When set to `true`, MrDocs outputs a warning message if the
        documentation of a symbol has errors such as duplicate parameters and
        parameters that don't exist.
     */
    bool warnIfDocError = true;

    /** Warn if parameters are not documented
    
        When set to `true`, MrDocs outputs a warning message if a named
        function parameter is not documented.
     */
    bool warnNoParamdoc = true;

    /** Warn if documented functions have unnamed parameters
    
        When set to `true`, MrDocs outputs a warning message if a documented
        function has a parameter that is not named.
     */
    bool warnUnnamedParam = false;

    /** Warn if enum values are not documented
    
        When set to `true`, MrDocs outputs a warning message if an enum value
        is not documented.
     */
    bool warnIfUndocEnumVal = true;

    /** Warn if a documentation reference is broken
    
        When set to `true`, MrDocs outputs a warning message if a reference in
        the documentation is broken.
     */
    bool warnBrokenRef = true;

    /** Treat warnings as errors
    
        When set to `true`, MrDocs treats warnings as errors and stops the
        generation of the documentation.
     */
    bool warnAsError = false;

    //--------------------------------------------
    // Miscellaneous
    // 
    // Miscellaneous options
    //--------------------------------------------

    /** Number of threads to use
    
        The desired level of concurrency: 0 for hardware-suggested.
     */
    unsigned concurrency = 0;

    /** Continue if files are not mapped correctly
    
        When set to true, MrDocs continues to generate the documentation even
        if some files are not mapped correctly.
        
        Files are not mapped correctly when the source file is not found or
        the compilation database does not contain the compiler flags for the
        source file.
     */
    bool ignoreMapErrors = false;

    /** Whether AST visitation failures should not stop the program
    
        When set to true, MrDocs continues to generate the documentation even
        if there are AST visitation failures.
        
        AST visitation failures occur when the source code contains constructs
        that are not supported by MrDocs.
     */
    bool ignoreFailures = false;

    /** Load the configuration from a YAML string
        
        This function loads the values from the YAML string without
        normalizing or validating them.
        
        After calling this function, call `normalize` to normalize
        and validate the options.
        
        @param s The PublicSettings object to load the configuration into
        @param configYaml The YAML string with the configuration
        @return Expected<void> with the error if any
     */
    static
    Expected<void>
    load(
        PublicSettings &s,
        std::string_view configYaml);

    /** Option Type
      */
    enum class OptionType {
        ListPathGlob,
        Unsigned,
        ListPath,
        ListString,
        Bool,
        FilePath,
        DirPath,
        Path,
        Enum,
        String,
        ListSymbolGlob,
    };

    /** Option validation traits
     */
    struct OptionProperties {
        OptionType type = OptionType::String;
        bool required = false;
        bool commandLineSink = false;
        bool commandLineOnly = false;
        bool mustExist = true;
        bool shouldExist = false;
        std::optional<int> minValue = std::nullopt;
        std::optional<int> maxValue = std::nullopt;
        std::optional<std::map<std::string, std::string>> filenameMapping = std::nullopt;
        std::variant<
            std::monostate,
            unsigned,
            std::vector<PathGlobPattern>,
            std::vector<SymbolGlobPattern>,
            SortSymbolBy,
            bool,
            LogLevel,
            std::string,
            Generator,
            BaseMemberInheritance,
            std::vector<std::string>> defaultValue = std::monostate();
        std::string relativeTo = {};
        std::optional<std::string> deprecated = std::nullopt;
    };

    /** Normalize the configuration values with a visitor
        
        This function normalizes and validates the configuration values.
        
        @param dirs The reference directories to resolve paths
        @param f The visitor
        @return Expected<void> with the error if any
      */
    template <class F>
    Expected<void>
    normalize(
        ReferenceDirectories const& dirs,
        F&& f)
    {
        // Configuration or compilation database files
        MRDOCS_TRY(std::forward<F>(f)(*this, "cmd-line-inputs", cmdLineInputs, dirs, OptionProperties{
            .type = OptionType::ListPath,
            .required = false,
            .commandLineSink = true,
            .commandLineOnly = true,
            .mustExist = true,
            .shouldExist = true,
            .filenameMapping = std::map<std::string, std::string>{
                { "mrdocs.yml", "config" },
                { "compile_commands.json", "compilation-database" },
                { "CMakeLists.txt", "compilation-database" },
            },
            .relativeTo = "<cwd>",
        }));
        // Mr.Docs configuration file
        MRDOCS_TRY(std::forward<F>(f)(*this, "config", config, dirs, OptionProperties{
            .type = OptionType::FilePath,
            .required = true,
            .commandLineOnly = true,
            .mustExist = true,
            .shouldExist = false,
            .defaultValue = std::string("<cwd>/mrdocs.yml"),
            .relativeTo = "<cwd>",
        }));
        // Path to the root directory of the source code
        MRDOCS_TRY(std::forward<F>(f)(*this, "source-root", sourceRoot, dirs, OptionProperties{
            .type = OptionType::DirPath,
            .required = false,
            .mustExist = true,
            .shouldExist = false,
            .defaultValue = std::string("<config-dir>"),
            .relativeTo = "<config-dir>",
        }));
        // Directory or file for generating output
        MRDOCS_TRY(std::forward<F>(f)(*this, "output", output, dirs, OptionProperties{
            .type = OptionType::Path,
            .required = false,
            .mustExist = false,
            .shouldExist = false,
            .defaultValue = std::string("<config-dir>/reference-output"),
            .relativeTo = "<config-dir>",
        }));
        // Path to the compilation database
        MRDOCS_TRY(std::forward<F>(f)(*this, "compilation-database", compilationDatabase, dirs, OptionProperties{
            .type = OptionType::FilePath,
            .required = false,
            .mustExist = true,
            .shouldExist = false,
            .relativeTo = "<config-dir>",
        }));
        // Input directories to extract symbols from
        MRDOCS_TRY(std::forward<F>(f)(*this, "input", input, dirs, OptionProperties{
            .type = OptionType::ListPath,
            .required = false,
            .mustExist = false,
            .shouldExist = true,
            .defaultValue = std::vector<std::string>({"<source-root>/."}),
            .relativeTo = "<config-dir>",
        }));
        // Recursively include files from "input" paths
        MRDOCS_TRY(std::forward<F>(f)(*this, "recursive", recursive, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // File patterns to include
        MRDOCS_TRY(std::forward<F>(f)(*this, "file-patterns", filePatterns, dirs, OptionProperties{
            .type = OptionType::ListPathGlob,
            .required = false,
            .defaultValue = std::vector<PathGlobPattern>({PathGlobPattern::create("*.hpp").value(), PathGlobPattern::create("*.h").value(), PathGlobPattern::create("*.hh").value(), PathGlobPattern::create("*.ipp").value(), PathGlobPattern::create("*.inc").value(), PathGlobPattern::create("*.cpp").value(), PathGlobPattern::create("*.cc").value(), PathGlobPattern::create("*.cxx").value(), PathGlobPattern::create("*.c").value(), PathGlobPattern::create("*.hxx").value()}),
        }));
        // Input directories to exclude
        MRDOCS_TRY(std::forward<F>(f)(*this, "exclude", exclude, dirs, OptionProperties{
            .type = OptionType::ListPath,
            .required = false,
            .mustExist = false,
            .shouldExist = true,
            .relativeTo = "<config-dir>",
        }));
        // File patterns to exclude
        MRDOCS_TRY(std::forward<F>(f)(*this, "exclude-patterns", excludePatterns, dirs, OptionProperties{
            .type = OptionType::ListPathGlob,
            .required = false,
            .relativeTo = "<config-dir>",
        }));
        // Symbol patterns to include
        MRDOCS_TRY(std::forward<F>(f)(*this, "include-symbols", includeSymbols, dirs, OptionProperties{
            .type = OptionType::ListSymbolGlob,
            .required = false,
            .relativeTo = "<config-dir>",
        }));
        // Symbol patterns to exclude
        MRDOCS_TRY(std::forward<F>(f)(*this, "exclude-symbols", excludeSymbols, dirs, OptionProperties{
            .type = OptionType::ListSymbolGlob,
            .required = false,
        }));
        // Exposition only symbols rendered as "see-below".
        MRDOCS_TRY(std::forward<F>(f)(*this, "see-below", seeBelow, dirs, OptionProperties{
            .type = OptionType::ListSymbolGlob,
            .required = false,
        }));
        // Symbols rendered as "implementation-defined"
        MRDOCS_TRY(std::forward<F>(f)(*this, "implementation-defined", implementationDefined, dirs, OptionProperties{
            .type = OptionType::ListSymbolGlob,
            .required = false,
        }));
        // Use the first line of the comment as the brief
        MRDOCS_TRY(std::forward<F>(f)(*this, "auto-brief", autoBrief, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Automatically find non-member functions
        MRDOCS_TRY(std::forward<F>(f)(*this, "auto-relates", autoRelates, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Automatically provide missing documentation for special functions and trivial metadata
        MRDOCS_TRY(std::forward<F>(f)(*this, "auto-function-metadata", autoFunctionMetadata, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Extract all symbols
        MRDOCS_TRY(std::forward<F>(f)(*this, "extract-all", extractAll, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Extraction policy for private class members
        MRDOCS_TRY(std::forward<F>(f)(*this, "extract-private", extractPrivate, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(false),
        }));
        // Extraction policy for private virtual methods of a class
        MRDOCS_TRY(std::forward<F>(f)(*this, "extract-private-virtual", extractPrivateVirtual, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(false),
        }));
        // Extraction policy for private base classes
        MRDOCS_TRY(std::forward<F>(f)(*this, "extract-private-bases", extractPrivateBases, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(false),
        }));
        // Extraction policy for static members of a file
        MRDOCS_TRY(std::forward<F>(f)(*this, "extract-static", extractStatic, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(false),
        }));
        // Extraction policy for records defined locally in source files
        MRDOCS_TRY(std::forward<F>(f)(*this, "extract-local-classes", extractLocalClasses, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Extraction policy for anonymous namespaces
        MRDOCS_TRY(std::forward<F>(f)(*this, "extract-anonymous-namespaces", extractAnonymousNamespaces, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Extraction policy for empty namespaces
        MRDOCS_TRY(std::forward<F>(f)(*this, "extract-empty-namespaces", extractEmptyNamespaces, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(false),
        }));
        // Determine how derived classes inherit base members
        MRDOCS_TRY(std::forward<F>(f)(*this, "inherit-base-members", inheritBaseMembers, dirs, OptionProperties{
            .type = OptionType::Enum,
            .required = false,
            .defaultValue = BaseMemberInheritance(BaseMemberInheritance::CopyDependencies),
        }));
        // Implicit template specializations used as base classes are extracted as dependencies
        MRDOCS_TRY(std::forward<F>(f)(*this, "extract-implicit-specializations", extractImplicitSpecializations, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Extraction policy for friend functions and classes
        MRDOCS_TRY(std::forward<F>(f)(*this, "extract-friends", extractFriends, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Sort the members of a record
        MRDOCS_TRY(std::forward<F>(f)(*this, "sort-members", sortMembers, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Determine how members of a record are sorted
        MRDOCS_TRY(std::forward<F>(f)(*this, "sort-members-by", sortMembersBy, dirs, OptionProperties{
            .type = OptionType::Enum,
            .required = false,
            .defaultValue = SortSymbolBy(SortSymbolBy::Name),
        }));
        // Determine how members of a namespace are sorted
        MRDOCS_TRY(std::forward<F>(f)(*this, "sort-namespace-members-by", sortNamespaceMembersBy, dirs, OptionProperties{
            .type = OptionType::Enum,
            .required = false,
            .defaultValue = SortSymbolBy(SortSymbolBy::Name),
        }));
        // Sort constructors first
        MRDOCS_TRY(std::forward<F>(f)(*this, "sort-members-ctors-1st", sortMembersCtors1St, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Sort destructors first
        MRDOCS_TRY(std::forward<F>(f)(*this, "sort-members-dtors-1st", sortMembersDtors1St, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Sort assignment operators first
        MRDOCS_TRY(std::forward<F>(f)(*this, "sort-members-assignment-1st", sortMembersAssignment1St, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Sort conversion operators last
        MRDOCS_TRY(std::forward<F>(f)(*this, "sort-members-conversion-last", sortMembersConversionLast, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Sort relational operators last
        MRDOCS_TRY(std::forward<F>(f)(*this, "sort-members-relational-last", sortMembersRelationalLast, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Detect and reduce SFINAE expressions
        MRDOCS_TRY(std::forward<F>(f)(*this, "sfinae", sfinae, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Detect and group function overloads
        MRDOCS_TRY(std::forward<F>(f)(*this, "overloads", overloads, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Generator used to create the documentation
        MRDOCS_TRY(std::forward<F>(f)(*this, "generator", generator, dirs, OptionProperties{
            .type = OptionType::Enum,
            .required = false,
            .defaultValue = Generator(Generator::Adoc),
        }));
        // Generate a multipage documentation
        MRDOCS_TRY(std::forward<F>(f)(*this, "multipage", multipage, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Base URL for links to source code
        MRDOCS_TRY(std::forward<F>(f)(*this, "base-url", baseUrl, dirs, OptionProperties{
            .type = OptionType::String,
            .required = false,
        }));
        // Path to the Addons directory
        MRDOCS_TRY(std::forward<F>(f)(*this, "addons", addons, dirs, OptionProperties{
            .type = OptionType::Path,
            .required = false,
            .mustExist = true,
            .shouldExist = false,
            .defaultValue = std::string("<mrdocs-root>/share/mrdocs/addons"),
            .relativeTo = "<config-dir>",
        }));
        // Path for the tagfile
        MRDOCS_TRY(std::forward<F>(f)(*this, "tagfile", tagfile, dirs, OptionProperties{
            .type = OptionType::FilePath,
            .required = false,
            .mustExist = false,
            .shouldExist = false,
            .defaultValue = std::string("<output-dir>/reference.tag.xml"),
            .relativeTo = "<output-dir>",
        }));
        // Use legible names
        MRDOCS_TRY(std::forward<F>(f)(*this, "legible-names", legibleNames, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Output an embeddable document
        MRDOCS_TRY(std::forward<F>(f)(*this, "embedded", embedded, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(false),
        }));
        // Show namespace pages in the documentation
        MRDOCS_TRY(std::forward<F>(f)(*this, "show-namespaces", showNamespaces, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Use the global namespace page as an index for all symbols
        MRDOCS_TRY(std::forward<F>(f)(*this, "global-namespace-index", globalNamespaceIndex, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // CMake arguments when generating the compilation database from CMakeLists.txt
        MRDOCS_TRY(std::forward<F>(f)(*this, "cmake", cmake, dirs, OptionProperties{
            .type = OptionType::String,
            .required = false,
        }));
        // Additional defines passed to the compiler
        MRDOCS_TRY(std::forward<F>(f)(*this, "defines", defines, dirs, OptionProperties{
            .type = OptionType::ListString,
            .required = false,
        }));
        // Use the system C++ standard library
        MRDOCS_TRY(std::forward<F>(f)(*this, "use-system-stdlib", useSystemStdlib, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(false),
        }));
        // C++ Standard Library include paths
        MRDOCS_TRY(std::forward<F>(f)(*this, "stdlib-includes", stdlibIncludes, dirs, OptionProperties{
            .type = OptionType::ListPath,
            .required = false,
            .mustExist = false,
            .shouldExist = true,
            .defaultValue = std::vector<std::string>({"<mrdocs-root>/share/mrdocs/headers/libcxx", "<mrdocs-root>/share/mrdocs/headers/clang"}),
            .relativeTo = "<config-dir>",
        }));
        // Use the system C standard library
        MRDOCS_TRY(std::forward<F>(f)(*this, "use-system-libc", useSystemLibc, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(false),
        }));
        // Standard Library include paths
        MRDOCS_TRY(std::forward<F>(f)(*this, "libc-includes", libcIncludes, dirs, OptionProperties{
            .type = OptionType::ListPath,
            .required = false,
            .mustExist = false,
            .shouldExist = true,
            .defaultValue = std::vector<std::string>({"<mrdocs-root>/share/mrdocs/headers/libc-stubs"}),
            .relativeTo = "<config-dir>",
        }));
        // System include paths
        MRDOCS_TRY(std::forward<F>(f)(*this, "system-includes", systemIncludes, dirs, OptionProperties{
            .type = OptionType::ListPath,
            .required = false,
            .mustExist = false,
            .shouldExist = true,
            .relativeTo = "<config-dir>",
        }));
        // Include paths
        MRDOCS_TRY(std::forward<F>(f)(*this, "includes", includes, dirs, OptionProperties{
            .type = OptionType::ListPath,
            .required = false,
            .mustExist = false,
            .shouldExist = true,
            .relativeTo = "<config-dir>",
        }));
        // Verbose output
        MRDOCS_TRY(std::forward<F>(f)(*this, "verbose", verbose, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(false),
        }));
        // The minimum reporting level
        MRDOCS_TRY(std::forward<F>(f)(*this, "report", report, dirs, OptionProperties{
            .type = OptionType::Unsigned,
            .required = false,
            .defaultValue = static_cast<unsigned>(-1),
            .deprecated = "Use `log-level` instead",
        }));
        // The minimum reporting level
        MRDOCS_TRY(std::forward<F>(f)(*this, "log-level", logLevel, dirs, OptionProperties{
            .type = OptionType::Enum,
            .required = false,
            .defaultValue = LogLevel(LogLevel::Info),
        }));
        // Enable warning messages
        MRDOCS_TRY(std::forward<F>(f)(*this, "warnings", warnings, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Warn if symbols are not documented
        MRDOCS_TRY(std::forward<F>(f)(*this, "warn-if-undocumented", warnIfUndocumented, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Warn if documentation has errors
        MRDOCS_TRY(std::forward<F>(f)(*this, "warn-if-doc-error", warnIfDocError, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Warn if parameters are not documented
        MRDOCS_TRY(std::forward<F>(f)(*this, "warn-no-paramdoc", warnNoParamdoc, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Warn if documented functions have unnamed parameters
        MRDOCS_TRY(std::forward<F>(f)(*this, "warn-unnamed-param", warnUnnamedParam, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(false),
        }));
        // Warn if enum values are not documented
        MRDOCS_TRY(std::forward<F>(f)(*this, "warn-if-undoc-enum-val", warnIfUndocEnumVal, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Warn if a documentation reference is broken
        MRDOCS_TRY(std::forward<F>(f)(*this, "warn-broken-ref", warnBrokenRef, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(true),
        }));
        // Treat warnings as errors
        MRDOCS_TRY(std::forward<F>(f)(*this, "warn-as-error", warnAsError, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(false),
        }));
        // Number of threads to use
        MRDOCS_TRY(std::forward<F>(f)(*this, "concurrency", concurrency, dirs, OptionProperties{
            .type = OptionType::Unsigned,
            .required = false,
            .commandLineOnly = true,
            .defaultValue = static_cast<unsigned>(0),
        }));
        // Continue if files are not mapped correctly
        MRDOCS_TRY(std::forward<F>(f)(*this, "ignore-map-errors", ignoreMapErrors, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(false),
        }));
        // Whether AST visitation failures should not stop the program
        MRDOCS_TRY(std::forward<F>(f)(*this, "ignore-failures", ignoreFailures, dirs, OptionProperties{
            .type = OptionType::Bool,
            .required = false,
            .defaultValue = static_cast<bool>(false),
        }));
        return {};
    }

    /** Visit all options
     */
    template <class F>
    void
    visit(F&& f)
    {
        std::forward<F>(f)("cmd-line-inputs", cmdLineInputs);
        std::forward<F>(f)("config", config);
        std::forward<F>(f)("source-root", sourceRoot);
        std::forward<F>(f)("output", output);
        std::forward<F>(f)("compilation-database", compilationDatabase);
        std::forward<F>(f)("input", input);
        std::forward<F>(f)("recursive", recursive);
        std::forward<F>(f)("file-patterns", filePatterns);
        std::forward<F>(f)("exclude", exclude);
        std::forward<F>(f)("exclude-patterns", excludePatterns);
        std::forward<F>(f)("include-symbols", includeSymbols);
        std::forward<F>(f)("exclude-symbols", excludeSymbols);
        std::forward<F>(f)("see-below", seeBelow);
        std::forward<F>(f)("implementation-defined", implementationDefined);
        std::forward<F>(f)("auto-brief", autoBrief);
        std::forward<F>(f)("auto-relates", autoRelates);
        std::forward<F>(f)("auto-function-metadata", autoFunctionMetadata);
        std::forward<F>(f)("extract-all", extractAll);
        std::forward<F>(f)("extract-private", extractPrivate);
        std::forward<F>(f)("extract-private-virtual", extractPrivateVirtual);
        std::forward<F>(f)("extract-private-bases", extractPrivateBases);
        std::forward<F>(f)("extract-static", extractStatic);
        std::forward<F>(f)("extract-local-classes", extractLocalClasses);
        std::forward<F>(f)("extract-anonymous-namespaces", extractAnonymousNamespaces);
        std::forward<F>(f)("extract-empty-namespaces", extractEmptyNamespaces);
        std::forward<F>(f)("inherit-base-members", inheritBaseMembers);
        std::forward<F>(f)("extract-implicit-specializations", extractImplicitSpecializations);
        std::forward<F>(f)("extract-friends", extractFriends);
        std::forward<F>(f)("sort-members", sortMembers);
        std::forward<F>(f)("sort-members-by", sortMembersBy);
        std::forward<F>(f)("sort-namespace-members-by", sortNamespaceMembersBy);
        std::forward<F>(f)("sort-members-ctors-1st", sortMembersCtors1St);
        std::forward<F>(f)("sort-members-dtors-1st", sortMembersDtors1St);
        std::forward<F>(f)("sort-members-assignment-1st", sortMembersAssignment1St);
        std::forward<F>(f)("sort-members-conversion-last", sortMembersConversionLast);
        std::forward<F>(f)("sort-members-relational-last", sortMembersRelationalLast);
        std::forward<F>(f)("sfinae", sfinae);
        std::forward<F>(f)("overloads", overloads);
        std::forward<F>(f)("generator", generator);
        std::forward<F>(f)("multipage", multipage);
        std::forward<F>(f)("base-url", baseUrl);
        std::forward<F>(f)("addons", addons);
        std::forward<F>(f)("tagfile", tagfile);
        std::forward<F>(f)("legible-names", legibleNames);
        std::forward<F>(f)("embedded", embedded);
        std::forward<F>(f)("show-namespaces", showNamespaces);
        std::forward<F>(f)("global-namespace-index", globalNamespaceIndex);
        std::forward<F>(f)("cmake", cmake);
        std::forward<F>(f)("defines", defines);
        std::forward<F>(f)("use-system-stdlib", useSystemStdlib);
        std::forward<F>(f)("stdlib-includes", stdlibIncludes);
        std::forward<F>(f)("use-system-libc", useSystemLibc);
        std::forward<F>(f)("libc-includes", libcIncludes);
        std::forward<F>(f)("system-includes", systemIncludes);
        std::forward<F>(f)("includes", includes);
        std::forward<F>(f)("verbose", verbose);
        std::forward<F>(f)("report", report);
        std::forward<F>(f)("log-level", logLevel);
        std::forward<F>(f)("warnings", warnings);
        std::forward<F>(f)("warn-if-undocumented", warnIfUndocumented);
        std::forward<F>(f)("warn-if-doc-error", warnIfDocError);
        std::forward<F>(f)("warn-no-paramdoc", warnNoParamdoc);
        std::forward<F>(f)("warn-unnamed-param", warnUnnamedParam);
        std::forward<F>(f)("warn-if-undoc-enum-val", warnIfUndocEnumVal);
        std::forward<F>(f)("warn-broken-ref", warnBrokenRef);
        std::forward<F>(f)("warn-as-error", warnAsError);
        std::forward<F>(f)("concurrency", concurrency);
        std::forward<F>(f)("ignore-map-errors", ignoreMapErrors);
        std::forward<F>(f)("ignore-failures", ignoreFailures);
    }

    /** Visit all options
     */
    template <class F>
    void
    visit(F&& f) const
    {
        std::forward<F>(f)("cmd-line-inputs", cmdLineInputs);
        std::forward<F>(f)("config", config);
        std::forward<F>(f)("source-root", sourceRoot);
        std::forward<F>(f)("output", output);
        std::forward<F>(f)("compilation-database", compilationDatabase);
        std::forward<F>(f)("input", input);
        std::forward<F>(f)("recursive", recursive);
        std::forward<F>(f)("file-patterns", filePatterns);
        std::forward<F>(f)("exclude", exclude);
        std::forward<F>(f)("exclude-patterns", excludePatterns);
        std::forward<F>(f)("include-symbols", includeSymbols);
        std::forward<F>(f)("exclude-symbols", excludeSymbols);
        std::forward<F>(f)("see-below", seeBelow);
        std::forward<F>(f)("implementation-defined", implementationDefined);
        std::forward<F>(f)("auto-brief", autoBrief);
        std::forward<F>(f)("auto-relates", autoRelates);
        std::forward<F>(f)("auto-function-metadata", autoFunctionMetadata);
        std::forward<F>(f)("extract-all", extractAll);
        std::forward<F>(f)("extract-private", extractPrivate);
        std::forward<F>(f)("extract-private-virtual", extractPrivateVirtual);
        std::forward<F>(f)("extract-private-bases", extractPrivateBases);
        std::forward<F>(f)("extract-static", extractStatic);
        std::forward<F>(f)("extract-local-classes", extractLocalClasses);
        std::forward<F>(f)("extract-anonymous-namespaces", extractAnonymousNamespaces);
        std::forward<F>(f)("extract-empty-namespaces", extractEmptyNamespaces);
        std::forward<F>(f)("inherit-base-members", inheritBaseMembers);
        std::forward<F>(f)("extract-implicit-specializations", extractImplicitSpecializations);
        std::forward<F>(f)("extract-friends", extractFriends);
        std::forward<F>(f)("sort-members", sortMembers);
        std::forward<F>(f)("sort-members-by", sortMembersBy);
        std::forward<F>(f)("sort-namespace-members-by", sortNamespaceMembersBy);
        std::forward<F>(f)("sort-members-ctors-1st", sortMembersCtors1St);
        std::forward<F>(f)("sort-members-dtors-1st", sortMembersDtors1St);
        std::forward<F>(f)("sort-members-assignment-1st", sortMembersAssignment1St);
        std::forward<F>(f)("sort-members-conversion-last", sortMembersConversionLast);
        std::forward<F>(f)("sort-members-relational-last", sortMembersRelationalLast);
        std::forward<F>(f)("sfinae", sfinae);
        std::forward<F>(f)("overloads", overloads);
        std::forward<F>(f)("generator", generator);
        std::forward<F>(f)("multipage", multipage);
        std::forward<F>(f)("base-url", baseUrl);
        std::forward<F>(f)("addons", addons);
        std::forward<F>(f)("tagfile", tagfile);
        std::forward<F>(f)("legible-names", legibleNames);
        std::forward<F>(f)("embedded", embedded);
        std::forward<F>(f)("show-namespaces", showNamespaces);
        std::forward<F>(f)("global-namespace-index", globalNamespaceIndex);
        std::forward<F>(f)("cmake", cmake);
        std::forward<F>(f)("defines", defines);
        std::forward<F>(f)("use-system-stdlib", useSystemStdlib);
        std::forward<F>(f)("stdlib-includes", stdlibIncludes);
        std::forward<F>(f)("use-system-libc", useSystemLibc);
        std::forward<F>(f)("libc-includes", libcIncludes);
        std::forward<F>(f)("system-includes", systemIncludes);
        std::forward<F>(f)("includes", includes);
        std::forward<F>(f)("verbose", verbose);
        std::forward<F>(f)("report", report);
        std::forward<F>(f)("log-level", logLevel);
        std::forward<F>(f)("warnings", warnings);
        std::forward<F>(f)("warn-if-undocumented", warnIfUndocumented);
        std::forward<F>(f)("warn-if-doc-error", warnIfDocError);
        std::forward<F>(f)("warn-no-paramdoc", warnNoParamdoc);
        std::forward<F>(f)("warn-unnamed-param", warnUnnamedParam);
        std::forward<F>(f)("warn-if-undoc-enum-val", warnIfUndocEnumVal);
        std::forward<F>(f)("warn-broken-ref", warnBrokenRef);
        std::forward<F>(f)("warn-as-error", warnAsError);
        std::forward<F>(f)("concurrency", concurrency);
        std::forward<F>(f)("ignore-map-errors", ignoreMapErrors);
        std::forward<F>(f)("ignore-failures", ignoreFailures);
    }

}; // struct PublicSettings

/** Convert a PublicSettings::Generator" to a string
 */
constexpr
std::string_view
to_string(PublicSettings::Generator e)
{
    switch (e)
    {
        case PublicSettings::Generator::Adoc:
            return "adoc";
        case PublicSettings::Generator::Html:
            return "html";
        case PublicSettings::Generator::Xml:
            return "xml";
    }
    return {};
}

/** Convert a PublicSettings::LogLevel" to a string
 */
constexpr
std::string_view
to_string(PublicSettings::LogLevel e)
{
    switch (e)
    {
        case PublicSettings::LogLevel::Trace:
            return "trace";
        case PublicSettings::LogLevel::Debug:
            return "debug";
        case PublicSettings::LogLevel::Info:
            return "info";
        case PublicSettings::LogLevel::Warn:
            return "warn";
        case PublicSettings::LogLevel::Error:
            return "error";
        case PublicSettings::LogLevel::Fatal:
            return "fatal";
    }
    return {};
}

/** Convert a PublicSettings::BaseMemberInheritance" to a string
 */
constexpr
std::string_view
to_string(PublicSettings::BaseMemberInheritance e)
{
    switch (e)
    {
        case PublicSettings::BaseMemberInheritance::Never:
            return "never";
        case PublicSettings::BaseMemberInheritance::Reference:
            return "reference";
        case PublicSettings::BaseMemberInheritance::CopyDependencies:
            return "copy-dependencies";
        case PublicSettings::BaseMemberInheritance::CopyAll:
            return "copy-all";
    }
    return {};
}

/** Convert a PublicSettings::SortSymbolBy" to a string
 */
constexpr
std::string_view
to_string(PublicSettings::SortSymbolBy e)
{
    switch (e)
    {
        case PublicSettings::SortSymbolBy::Name:
            return "name";
        case PublicSettings::SortSymbolBy::Location:
            return "location";
    }
    return {};
}

} // namespace clang::mrdocs

#endif // MRDOCS_PUBLIC_SETTINGS_HPP
