= Reference
:mrdocs:

[#index]
== Global namespace

=== Namespaces

[cols=1]
|===
| Name
| link:#B[`B`] 
|===

=== Types

[cols=2]
|===
| Name
| Description
| link:#A-09[`A`] 
| The partial specialization of A is enabled via a template parameter
| link:#A-07[`A&lt;T&gt;`] 
| Specialization for integral types
| link:#S-02[`S`] 
| SFINAE with std&colon;&colon;void&lowbar;t
| link:#S-08[`S&lt;T, std::void&lowbar;t&lt;T::a::b&gt;&gt;`] 
| SFINAE with std&colon;&colon;void&lowbar;t
|===

=== Functions

[cols=2]
|===
| Name
| Description
| link:#f1[`f1`] 
| Enabled via return type
| link:#f10[`f10`] 
| Enabled via type template parameter
| link:#f2[`f2`] 
| Enabling a specified return type
| link:#f3[`f3`] 
| Enabling a specified return type in another namespace
| link:#f4[`f4`] 
| Enabled via return type with std&colon;&colon;enable&lowbar;if
| link:#f5[`f5`] 
| Enabled via a non&hyphen;type template parameter with helper
| link:#f6[`f6`] 
| Enabled via a non&hyphen;type template parameter without helper
| link:#f7[`f7`] 
| Enabled via a non&hyphen;type template parameter using int instead of bool
| link:#f8[`f8`] 
| Enabled via parameter without helper
| link:#f9[`f9`] 
| Enabled via parameter with helper
|===

[#B]
== B

=== Types

[cols=2]
|===
| Name
| Description
| link:#B-C[`C`] 
| 
|===

[#B-C]
== link:#B[B]::C

=== Synopsis

Declared in `&lt;sfinae&period;cpp&gt;`

[source,cpp,subs="verbatim,replacements,macros,-callouts"]
----
struct C;
----

=== Non-Member Functions

[cols=2]
|===
| Name
| Description
| link:#f3[`&colon;&colon;f3`]
| Enabling a specified return type in another namespace
|===

[#A-09]
== A

The partial specialization of A is enabled via a template parameter

=== Synopsis

Declared in `&lt;sfinae&period;cpp&gt;`

[source,cpp,subs="verbatim,replacements,macros,-callouts"]
----
template&lt;
    class T,
    class Enable = void&gt;
class A;
----

[#A-07]
== link:#A-09[A]&lt;T&gt;

Specialization for integral types

=== Synopsis

Declared in `&lt;sfinae&period;cpp&gt;`

[source,cpp,subs="verbatim,replacements,macros,-callouts"]
----
template&lt;class T&gt;
requires std&colon;&colon;is&lowbar;integral&lowbar;v&lt;T&gt;
class link:#A-09[A]&lt;T&gt;;
----

[#S-02]
== S

SFINAE with std&colon;&colon;void&lowbar;t

=== Synopsis

Declared in `&lt;sfinae&period;cpp&gt;`

[source,cpp,subs="verbatim,replacements,macros,-callouts"]
----
template&lt;
    class T,
    class Enable = void&gt;
struct S;
----

=== Member Functions

[cols=1]
|===
| Name
| link:#S-02-store[`store`] 
|===

[#S-02-store]
== link:#S-02[S]::store

=== Synopsis

Declared in `&lt;sfinae&period;cpp&gt;`

[source,cpp,subs="verbatim,replacements,macros,-callouts"]
----
void
store(void const*);
----

[#S-08]
== link:#S-02[S]&lt;T, std::void&lowbar;t&lt;T::a::b&gt;&gt;

SFINAE with std&colon;&colon;void&lowbar;t

=== Synopsis

Declared in `&lt;sfinae&period;cpp&gt;`

[source,cpp,subs="verbatim,replacements,macros,-callouts"]
----
template&lt;class T&gt;
struct link:#S-02[S]&lt;T, std::void&lowbar;t&lt;T::a::b&gt;&gt;;
----

=== Member Functions

[cols=1]
|===
| Name
| link:#S-08-store[`store`] 
|===

[#S-08-store]
== link:#S-08[S&lt;T, std::void&lowbar;t&lt;T::a::b&gt;&gt;]::store

=== Synopsis

Declared in `&lt;sfinae&period;cpp&gt;`

[source,cpp,subs="verbatim,replacements,macros,-callouts"]
----
void
store(void const*);
----

[#f1]
== f1

Enabled via return type

=== Synopsis

Declared in `&lt;sfinae&period;cpp&gt;`

[source,cpp,subs="verbatim,replacements,macros,-callouts"]
----
template&lt;class T&gt;
T
f1(T value)
requires std&colon;&colon;is&lowbar;integral&lowbar;v&lt;T&gt;;
----

[#f10]
== f10

Enabled via type template parameter

=== Synopsis

Declared in `&lt;sfinae&period;cpp&gt;`

[source,cpp,subs="verbatim,replacements,macros,-callouts"]
----
template&lt;class T&gt;
requires std&colon;&colon;is&lowbar;integral&lowbar;v&lt;T&gt;
void
f10(T value);
----

=== Description

This pattern should not be used because the function signature is unmodified and therefore only supports one overload&period;

It&apos;s a common mistake is to declare two function templates that differ only in their default template arguments&period;

This does not work because the declarations are treated as redeclarations of the same function template (default template arguments are not accounted for in function template equivalence)&period;

[#f2]
== f2

Enabling a specified return type

=== Synopsis

Declared in `&lt;sfinae&period;cpp&gt;`

[source,cpp,subs="verbatim,replacements,macros,-callouts"]
----
template&lt;class T&gt;
int
f2(T value)
requires std&colon;&colon;is&lowbar;integral&lowbar;v&lt;T&gt;;
----

[#f3]
== f3

Enabling a specified return type in another namespace

=== Synopsis

Declared in `&lt;sfinae&period;cpp&gt;`

[source,cpp,subs="verbatim,replacements,macros,-callouts"]
----
template&lt;class T&gt;
link:#B-C[B::C]
f3(T value)
requires std&colon;&colon;is&lowbar;integral&lowbar;v&lt;T&gt;;
----

[#f4]
== f4

Enabled via return type with std&colon;&colon;enable&lowbar;if

=== Synopsis

Declared in `&lt;sfinae&period;cpp&gt;`

[source,cpp,subs="verbatim,replacements,macros,-callouts"]
----
template&lt;class T&gt;
T
f4(T value)
requires std&colon;&colon;is&lowbar;integral&lowbar;v&lt;T&gt;;
----

[#f5]
== f5

Enabled via a non&hyphen;type template parameter with helper

=== Synopsis

Declared in `&lt;sfinae&period;cpp&gt;`

[source,cpp,subs="verbatim,replacements,macros,-callouts"]
----
template&lt;class T&gt;
requires std&colon;&colon;is&lowbar;integral&lowbar;v&lt;T&gt;
T
f5(T value);
----

[#f6]
== f6

Enabled via a non&hyphen;type template parameter without helper

=== Synopsis

Declared in `&lt;sfinae&period;cpp&gt;`

[source,cpp,subs="verbatim,replacements,macros,-callouts"]
----
template&lt;class T&gt;
requires std&colon;&colon;is&lowbar;integral&lowbar;v&lt;T&gt;
T
f6(T value);
----

[#f7]
== f7

Enabled via a non&hyphen;type template parameter using int instead of bool

=== Synopsis

Declared in `&lt;sfinae&period;cpp&gt;`

[source,cpp,subs="verbatim,replacements,macros,-callouts"]
----
template&lt;class T&gt;
requires std&colon;&colon;is&lowbar;integral&lowbar;v&lt;T&gt;
void
f7(T value);
----

[#f8]
== f8

Enabled via parameter without helper

=== Synopsis

Declared in `&lt;sfinae&period;cpp&gt;`

[source,cpp,subs="verbatim,replacements,macros,-callouts"]
----
template&lt;class T&gt;
T
f8(T value)
requires std&colon;&colon;is&lowbar;integral&lowbar;v&lt;T&gt;;
----

[#f9]
== f9

Enabled via parameter with helper

=== Synopsis

Declared in `&lt;sfinae&period;cpp&gt;`

[source,cpp,subs="verbatim,replacements,macros,-callouts"]
----
template&lt;class T&gt;
T
f9(T value)
requires std&colon;&colon;is&lowbar;integral&lowbar;v&lt;T&gt;;
----


[.small]#Created with https://www.mrdocs.com[MrDocs]#
