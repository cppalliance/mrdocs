#
# Licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# Copyright (c) 2024 Alan de Freitas (alandefreitas@gmail.com)
#
# Official repository: https://github.com/cppalliance/mrdocs
#

import sys
import json
import os


def to_camel_case(kebab_str):
    if ' ' in kebab_str:
        parts = kebab_str.split(' ')
        return to_camel_case('-'.join(parts))

    if '.' in kebab_str:
        parts = kebab_str.split('.')
        return '.'.join([to_camel_case(part) for part in parts])

    kebab_str = kebab_str[0].lower() + kebab_str[1:]
    components = kebab_str.split('-')
    return components[0] + ''.join(x.title() for x in components[1:])


def to_pascal_case(kebab_str):
    separator_chars = [' ', '<', '>']
    for separator_char in separator_chars:
        if separator_char in kebab_str:
            parts = kebab_str.split(separator_char)
            return to_pascal_case('-'.join(parts))

    if '.' in kebab_str:
        parts = kebab_str.split('.')
        return '.'.join([to_pascal_case(part) for part in parts])

    components = kebab_str.split('-')
    return ''.join(x.title() for x in components)


def generate_header_comment():
    header_comment = '/*\n'
    header_comment += ' * This file is generated automatically from the json file\n'
    header_comment += ' * `src/lib/Metadata/InfoNodes.json`. Do not edit this file\n'
    header_comment += ' * manually. Instead, edit the json file and run the script\n'
    header_comment += ' * `util/generate-info-files.py` to regenerate this file.\n'
    header_comment += ' */\n\n'
    return header_comment


def generate_info_nodes_pascal_inc(info_nodes):
    contents = generate_header_comment()
    contents += f'#ifndef INFO\n'
    contents += f'#define INFO(PascalName) \n'
    contents += f'#endif\n\n'
    for info_node in info_nodes:
        contents += f'INFO({to_pascal_case(info_node["name"])})\n'
    contents += f'\n#undef INFO\n\n'
    return contents


def generate_info_nodes_lowercase_inc(info_nodes):
    contents = generate_header_comment()
    contents += f'#ifndef INFO\n'
    contents += f'#define INFO(LowerName) \n'
    contents += f'#endif\n\n'
    for info_node in info_nodes:
        contents += f'INFO({info_node["name"].lower()})\n'
    contents += f'\n#undef INFO\n'
    return contents

def generate_info_nodes_camelcase_inc(info_nodes):
    contents = generate_header_comment()
    contents += f'#ifndef INFO\n'
    contents += f'#define INFO(CamelName) \n'
    contents += f'#endif\n\n'
    for info_node in info_nodes:
        contents += f'INFO({to_camel_case(info_node["name"])})\n'
    contents += f'\n#undef INFO\n'
    return contents


def generate_info_nodes_pascal_and_lowercase_inc(info_nodes):
    contents = generate_header_comment()
    contents += f'#ifndef INFO\n'
    contents += f'#define INFO(PascalName, LowerName) \n'
    contents += f'#endif\n\n'
    for info_node in info_nodes:
        contents += f'INFO({to_pascal_case(info_node["name"])}, {info_node["name"].lower()})\n'
    contents += f'\n#undef INFO\n'
    return contents

def generate_info_nodes_pascal_and_camelcase_inc(info_nodes):
    contents = generate_header_comment()
    contents += f'#ifndef INFO\n'
    contents += f'#define INFO(PascalName, CamelName) \n'
    contents += f'#endif\n\n'
    for info_node in info_nodes:
        contents += f'INFO({to_pascal_case(info_node["name"])}, {to_camel_case(info_node["name"])})\n'
    contents += f'\n#undef INFO\n'
    return contents

def generate_info_nodes_camel_and_lowercase_inc(info_nodes):
    contents = generate_header_comment()
    contents += f'#ifndef INFO\n'
    contents += f'#define INFO(CamelName, LowerName) \n'
    contents += f'#endif\n\n'
    for info_node in info_nodes:
        contents += f'INFO({to_camel_case(info_node["name"])}, {info_node["name"].lower()})\n'
    contents += f'\n#undef INFO\n'
    return contents

def to_plural(name):
    if name.endswith('y'):
        return name[:-1] + 'ies'
    if name.endswith('s'):
        return name + 'es'
    return name + 's'


def generate_info_nodes_pascal_plural_inc(info_nodes):
    contents = generate_header_comment()
    contents += f'#ifndef INFO\n'
    contents += f'#define INFO(PluralName) \n'
    contents += f'#endif\n\n'
    for info_node in info_nodes:
        contents += f'INFO({to_plural(to_pascal_case(info_node["name"]))})\n'
    contents += f'\n#undef INFO\n'
    return contents

def generate_info_nodes_pascal_plural_and_lowercase_plural_inc(info_nodes):
    contents = generate_header_comment()
    contents += f'#ifndef INFO\n'
    contents += f'#define INFO(PluralName, LowerPluralName) \n'
    contents += f'#endif\n\n'
    for info_node in info_nodes:
        contents += f'INFO({to_plural(to_pascal_case(info_node["name"]))}, {to_plural(info_node["name"].lower())})\n'
    contents += f'\n#undef INFO\n'
    return contents

def generate(info_nodes, output_dir):
    print('Generating Configuration Information...')

    mrdocs_build_include_dir = os.path.join(output_dir, 'include', 'mrdocs')
    mrdocs_info_nodes_include_dir = os.path.join(mrdocs_build_include_dir, 'Metadata')

    all_dirs = [mrdocs_build_include_dir, mrdocs_info_nodes_include_dir]
    for dir in all_dirs:
        if not os.path.exists(dir):
            os.makedirs(dir)

    files_content = {
        'InfoNodesPascal.inc': generate_info_nodes_pascal_inc(info_nodes),
        'InfoNodesPascalAndLower.inc': generate_info_nodes_pascal_and_lowercase_inc(info_nodes),
        'InfoNodesPascalAndCamel.inc': generate_info_nodes_pascal_and_camelcase_inc(info_nodes),
        'InfoNodesCamelAndLower.inc': generate_info_nodes_camel_and_lowercase_inc(info_nodes),
        'InfoNodesLower.inc': generate_info_nodes_lowercase_inc(info_nodes),
        'InfoNodesCamel.inc': generate_info_nodes_camelcase_inc(info_nodes),
        'InfoNodesPascalPlural.inc': generate_info_nodes_pascal_plural_inc(info_nodes),
        'InfoNodesPascalPluralAndLowerPlural.inc': generate_info_nodes_pascal_plural_and_lowercase_plural_inc(info_nodes)
    }

    for filename, content in files_content.items():
        with open(os.path.join(mrdocs_info_nodes_include_dir, filename), 'w') as f:
            f.write(content)


def main():
    # Read command line arguments
    input_file = sys.argv[1]
    output_dir = sys.argv[2]

    # ensure input is a json file
    if not input_file.endswith('.json'):
        print('Error: input file must be a json file')
        sys.exit(1)
    if os.path.exists(output_dir) and not os.path.isdir(output_dir):
        print('Error: output directory already exists')
        sys.exit(1)

    # parse input file
    with open(input_file, 'r') as f:
        info_nodes = json.load(f)

    generate(info_nodes, output_dir)


if __name__ == "__main__":
    main()
